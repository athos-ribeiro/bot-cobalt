#!perl

# cobalt2-mkpasswd
# bcrypt-enabled mkpasswd

use 5.10.0;
use strict;
use warnings;

my $version = '0.10';

use Term::ReadKey;

use Time::HiRes qw/ gettimeofday tv_interval /;

use Getopt::Long;

my $type = 'bcrypt';
my $bcrypt_cost = '08';
my $showtimer = 0;
my $check;
GetOptions(
  'method=s' => \$type,
  'workcost=s' => \$bcrypt_cost,
  'benchmark!' => \$showtimer,

  'check=s' => \$check,

  'version' => sub {
     say "Cobalt tools/mkpasswd v".$version;
     say "Adapted from Cobalt::Utils";
     exit 0
   },

  'help' => sub {
    print(
      "$0 [OPTS]... [PASSWD]\n",
      "Opts:\n",
      " --benchmark\n",
      "   Show timers. [Default: off]\n",
      "\n",
      " --method=<TYPE>\n",
      "   Default: -m bcrypt\n",
      "   Types: \n",
      "   - bcrypt (requires Crypt::Eksblowfish)\n",
      "   - sha256 (requires glibc2.7+)\n",
      "   - sha512 (requires glibc2.7+)\n",
      "   - md5 (fast, portable, insecure)\n",
      "\n",
      " --check=<HASH>\n",
      "   Compare password against specified hash.\n",
      "\n",
      " bcrypt-only:\n",
      " --workcost=<two digit power of 2>\n",
      "   Default: -w 08\n",
      "   bcrypt work cost factor; higher is slower.\n",
      "   When it comes to comparing passwds, slower can be better.\n",
      "   See http://codahale.com/how-to-safely-store-a-password/\n",
    );
    exit 0
  },  
);

eval { require Crypt::Eksblowfish::Bcrypt; };
my $have_bcrypt = $@ ? 0 : 1;

my $pwd;
if (@ARGV) {
  $pwd = $ARGV[0];
} else {
  ReadMode('noecho');
  print "Password: ";
  $pwd = <STDIN>;
  chomp($pwd);
  ReadMode(0);
  print "\n";
}

my $timer0 = [gettimeofday()];

if ($check) {
  if ( pwd_compare($pwd, $check) ) {
    say "Password matches";
    say $check;
  } else {
    say "NO MATCH";
  }
} else {
  say pwd_generate($pwd);
}

my $interval0 = tv_interval($timer0);
say " bench: $type, timer0 -> $interval0" if $showtimer;

## from Circe:
sub pwd_generate {
  my $pwd = shift || return;
  my @p = ('a' .. 'z', 'A' .. 'Z', 0 .. 9, '_',);
  my $salt = join '', map { $p[rand@p] } 1 .. 8;
  given ($type)
  {
    when (/sha-?512/i) {  ## SHA-512: glibc-2.7+
      ## unfortunately mostly only glibc has support in crypt()
      ## SHA has variable length salts (up to 16)
      ## varied salt lengths can (maybe) slow down attacks
      ## (so says Drepper, anyway)
      $salt .= $p[rand@p] for 1 .. rand 8;
      $salt = '$6$'.$salt.'$';
    }

    when (/sha-?256/i) {  ## SHA-256: glibc-2.7+
      $salt .= $p[rand@p] for 1 .. rand 8;
      $salt = '$5$'.$salt.'$';
    }

    when (/^bcrypt$/i) {  ## Bcrypt: requires Crypt::Eksblowfish
      ## blowfish w/ cost factor
      unless ($have_bcrypt) {
        say("WARNING: Attempting to use bcrypt but missing Crypt::Eksblowfish");
        say("WARNING: Defaulting to MD5 instead . . . !");
        $salt = '$1$'.$salt.'$';  ## no bcrypt here, generate md5 instead (sadface)
      } else {
        ## cost value is configurable, but 08 is a good choice.
        ## has to be a two digit power of 2. pad with 0 as needed
        my $cost = $bcrypt_cost // '08';
        $cost = '0'.$cost if length $cost == 1;
        ## bcrypt expects 16 octets of salt:
        $salt = join('', map { chr(int(rand(256))) } 1 .. 16);
        ## ...base64-encoded via bcrypt's en_base64:
        $salt = Crypt::Eksblowfish::Bcrypt::en_base64( $salt );
        ## actual settings string to feed bcrypt ($2a$COST$SALT)
        $salt = join('', '$2a$', $cost, '$', $salt);
        return Crypt::Eksblowfish::Bcrypt::bcrypt($pwd, $salt)
      }
    } 

    when ("DES") {
      ## not documented because it's a Very Bad Idea ...
      ## but here in case you're stuck with the world's worst crypt()
      ## srsly though, don't use it. no, really, the 80s are over, promise.
      $salt = join '', map { $p[rand@p] } 1..2;
    }

    default {  ## defaults to MD5 -- portable, fast, but weak
      $salt = '$1$'.$salt.'$';
    }
  }
  my $crypt = crypt($pwd, $salt);
  return $crypt
}

sub pwd_compare {
  my $pwd   = shift || return;
  my $crypt = shift || return;

  if ( index($crypt, '$2a$') == 0 ) ## bcrypted
  {
    unless ($have_bcrypt) {
      say("ERROR; Missing Crypt::Eksblowfish!");
      say("ERROR; Cannot compare bcrypted password!");
      return 0
    } else {
      return 0 unless $crypt eq
        Crypt::Eksblowfish::Bcrypt::bcrypt($pwd, $crypt);
    }
  }
  else  ## some crypt() method, hopefully we have it!
  {
    return 0 unless $crypt eq crypt($pwd, $crypt);
  }

  return 1
}


=pod

=head1 NAME

 cobalt2-mkpasswd - bcrypt-enabled mkpasswd

=head1 SYNOPSIS

 mkpasswd [OPTIONS]... [PASSWD]

=head1 OPTIONS

 -h, --help

 -b, --benchmark
     Show timers.

 -m, --method <TYPE>
     crypt method.
     Types:
       bcrypt (default; requires Crypt::Eksblowfish)
       sha512 (requires glibc2.7+)
       sha256 (requires glibc2.7+)
       md5 (fast, portable, weak)

 -c, --check <HASH>
     Check password against <HASH>.
     Method will be auto-detected.

 -w, --workcost <COST>
     bcrypt-only.
     Specify a work cost factor. Higher is slower.
     Must be a two-digit power of 2.
     Pad with zeros as necessary.

=head1 DESCRIPTION

While SHA512 isn't a bad choice if you have it, bcrypt has the 
advantage of including a configurable work cost factor.

A higher work cost factor exponentially increases hashing time.

That means it takes significantly longer to compare a very large 
number of passwords against yours.

=head1 AUTHOR

http://www.cobaltirc.org

=cut
