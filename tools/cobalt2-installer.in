#!perl
my $version = '0.12';

use 5.12.1;
use strict;
use warnings;

use File::Path;

use JSON;

use Cobalt::Utils qw/ rplprintf mkpasswd /;

STDOUT->autoflush(1);

my $rcfile = $ENV{HOME} . "/.cobalt2rc";

use Getopt::Long;
GetOptions(

  version => sub {
    say "$0 $version";
    exit 0
   },

  help => sub {
    print(
      "$0 $version\n\n",
      "Options:\n",
      "  -c, --rcfile=PATH    Path to cobalt2 rcfile\n",
      "                       [default: $rcfile]\n",
    );
    exit 0
   },

  'rcfile=s' => \$rcfile,
  'config=s' => \$rcfile,
);


sub _deserialize_etc {
  ## Pulls our /etc from our DATA handle
  my $json;
  {  local $/ ; $json = <DATA>;  }
  my $ref = decode_json $json; 
  return ref $ref eq 'HASH' ? $ref : () ;
}

sub _slurp {
  my ($path) = @_;
  ## Slurp a file
  my $str;
  open(my $fh, '<', $path) or die "failed file read: $path: $!" ;
  {  local $/ ; $str = <$fh>;  }
  close($fh) or warn "failed to close $path: $!\n";
  return $str
}

sub _ans {
  ## f.ex: my $default_yes = _ans(my $in = <STDIN>, 'Y')
  my ($stdin, $default) = @_;
  chomp($stdin);
  $stdin = $stdin ? $stdin : $default ;
  return unless $stdin =~ /^Y/i;
}

## RC_* funcs
sub RC_Read {
  ## Read the current $rcfile
  my $str = _slurp($rcfile);
  my ($BASE, $ETC, $VAR);
  eval $str;
  if ($@) {
    die "Errors reported during rc parsing; $@";
  }
  return ($BASE, $ETC, $VAR);
}

sub RC_Write {
  my ($relative_base) = @_;
  ## Pass me a base path relative to $ENV{HOME} such as 'cobalt2'
  ## Writes a basic cobalt2rc to current value of $rcfile
  my $str = join "\n",
    '## cobalt2rc automatically generated at '.scalar localtime,
    '$BASE = $ENV{HOME} . "/'.$relative_base.'";' ,
    '$ETC = $BASE . "/etc";' ,
    '$VAR = $BASE . "/var";' , "\n"
  ;

  open(my $fh, '>', $rcfile)
    or die "failed to open $rcfile: $!";
  print $fh $str;
  close($fh) or warn "close failed for $rcfile: $!\n";

  say ">! wrote rcfile";
  say ">! ETC is: ". $ENV{HOME} ."/". $relative_base . "/etc" ;
  say ">! VAR is: ". $ENV{HOME} ."/". $relative_base . "/var" ;
  say ">! To change, edit $rcfile\n";
}


## Conf_* funcs

sub Conf_write_confs {
  ## Conf_write_confs($vars_replacement_hash)
  my ($vars_h) = @_;
  my ($base, $etc, $var) = RC_Read();
  File::Path::mkpath( $var ."/db" );
  File::Path::mkpath( $var ."/tmp" );
  my $ref = _deserialize_etc();
  ## should have a vars hash for rplprintf, and RC_Read can give us an etc dir path
  ## use File::Path to create our dir structure
  ## write our deserialized confs back out
  ## run rplprintf against each file before writing
  for my $confpath (keys %$ref) {

    my $output_path = $etc ."/". $confpath ;
    (undef, my $dir, my $file) = File::Spec->splitpath($output_path);
    File::Path::mkpath($dir) if $dir;
    die "tried to create $dir but can't be found?" unless -e $dir;

    my $content = $ref->{$confpath};
    my $output = rplprintf( $content, $vars_h );

    print ">! Writing $output_path .. ";

    if (-e $output_path) {
      say ">! Exists already: $output_path";
      print "Should I overwrite it? [y/N] ";
      if ( _ans(my $in = <STDIN>, 'N') ) {
        say ">! Overwriting $output_path";
      } else { next }
    }

    open(my $fh, '>', $output_path) or die "open failed: $output_path: $!";
    print $fh $output;
    close($fh) or warn "close failed on $output_path: $!\n";

    print "OK\n";
  }

  say ">! Finished writing confs.";
}


sub Conf_interactive {
  my $cf = {};

  print(
    "Interactively configuring basic cobalt2 opts.\n",
    "This installer only covers the most basic set of options.\n",
    "You should review etc/ yourself when finished.\n\n",
    "Defaults are shown [like this]\n\n",
  );

  say ">! Configuring cobalt.conf";

  print "Bot's nickname [cobalt2] ";
  $cf->{CFG_BOT_NICK} = <STDIN>;
  chomp $cf->{CFG_BOT_NICK} ;
  $cf->{CFG_BOT_NICK} ||= 'cobalt2';

  print "\n";

  print "Bot's username [cobalt] ";
  $cf->{CFG_BOT_USERNAME} = <STDIN>;
  chomp $cf->{CFG_BOT_USERNAME} ;
  $cf->{CFG_BOT_USERNAME} ||= 'cobalt';

  print "\n";

  print "Bot's 'realname' [cobalt2 bot] ";
  $cf->{CFG_BOT_REALNAME} = <STDIN>;
  chomp $cf->{CFG_BOT_REALNAME} ;
  $cf->{CFG_BOT_REALNAME} ||= 'cobalt2 bot';

  print "\n";

  print "Remote ServerAddr [irc.cobaltirc.org] ";
  $cf->{CFG_SERVER_ADDR} = <STDIN>;
  chomp $cf->{CFG_SERVER_ADDR} ;
  $cf->{CFG_SERVER_ADDR} ||= 'irc.cobaltirc.org';

  print "\n";

  print "Use SSL for this server? [y/N] ";
  my $usessl = _ans(my $in = <STDIN>, 'n');
  $cf->{CFG_USE_SSL} = $usessl ? 1 : 0 ;

  print "\n";

  my $default_irc_port = $usessl ? 6697 : 6667 ;
  print "Remote port [$default_irc_port] ";
  $cf->{CFG_SERVER_PORT} = <STDIN>;
  chomp $cf->{CFG_SERVER_PORT} ;
  $cf->{CFG_SERVER_PORT} ||= $default_irc_port;

  print "\n";

  say "You need to specify a command character for the bot.";
  say "This is used to prefix various plugin-provided commands.";
  print "Bot's command character [ ! ] ";
  $cf->{CFG_CMD_CHAR} = <STDIN>;
  chomp $cf->{CFG_CMD_CHAR};
  $cf->{CFG_CMD_CHAR} ||= '!' ;

  print "\n";

  say ">! Done configuring cobalt.conf" ;
  say ">! There are many more opts; review the file!";

  print "\n";

  # plugins.conf is probably fine with a suitable example file
  
  say ">! Configuring channels.conf\n";
  say "You're going to want to set up an initial channel.";

  print "Channel name [#otw] ";
  $cf->{CHAN} = <STDIN>;
  chomp $cf->{CHAN};
  $cf->{CHAN} ||= '#otw';

  print "\n";

  ## FIXME note about ChanMgr?
  say "You may want to edit channels.conf and add other channels.\n";

  say ">! Configuring auth.conf\n";

  say "You'll want at least one SuperUser to control the bot.";
  say "Authorized users have a username that may or may not be their IRC nick.";
  print "Username for your superuser: ";
  $cf->{AUTH_USER} = <STDIN>;
  chomp $cf->{AUTH_USER};
  $cf->{AUTH_USER} ||= 'MyUser';

  print "\n";

  say "By default, passwords are encrypted using bcrypt.";
  say "bcrypt is a pretty secure way to generate password hashes.";

  eval "require Term::ReadKey";
  if ($@) {
    say ">! WARNING: No Term::ReadKey found.";
    say ">! Cannot blank passwd prompts!"; 
  } else {
    Term::ReadKey->import('ReadMode');
  }
  print "Passwd for user ".$cf->{AUTH_USER}.": ";
  ReadMode('noecho') if exists &ReadMode;
  my $clearpwd = <STDIN>;
  ReadMode(0) if exists &ReadMode;
  chomp $clearpwd;
  $cf->{AUTH_PASS} = mkpasswd($clearpwd || rand);

  print "\n";
  say "This user needs at least one hostmask to match on.";
  say "For example: *avenj@*.oppresses.us";
  say "(You can add others to auth.conf later.)";
  print "Mask: ";
  $cf->{AUTH_MASK} = <STDIN>;
  chomp $cf->{AUTH_MASK};
  $cf->{AUTH_MASK} ||= '*nobody@nowhere.org';
  say "\nAdded mask $cf->{AUTH_MASK} for user $cf->{AUTH_USER}";
  say "You may want to edit auth.conf to add/edit superusers and masks.";
  ## FIXME chmod auth.conf ?
  print "\n";

  return $cf
}


## MAIN
print(
  "This is the cobalt2 install helper.\n",
  "This script will create a cobalt2rc file specifying install paths.\n",
  "It will also help you initialize some starter cobalt2 conf files.\n",
  "> Press ENTER to continue, Ctrl+C to quit.",
);
<STDIN>;

say "> Default rcfile: $rcfile";

## prompt user for a rcfile path
print "> Enter a different rcfile location? [y/N] ";
if ( _ans(my $in = <STDIN>, 'N') ) {
  do {
    print "> Path to rcfile: ";
    $rcfile = <STDIN>; chomp($rcfile);
  } until $rcfile;
}

say ">! using rcfile: $rcfile";

## prompt user for a relative basedir
say "> Cobalt needs a place for etc/ and var/ to live.";
say "> Normally this would be somewhere in your HOME directory.";
say "> Specify a directory relative to your HOME for cobalt to live:";
print "[cobalt2] ";
my $relative_basedir = <STDIN> ; chomp($relative_basedir);

if (-e $rcfile) {
  say ">! $rcfile seems to already exist.";
  say ">! Should I overwrite it? [y/N] ";
  if ( _ans(my $in = <STDIN>, 'N') ) {
    RC_Write($relative_basedir);
  } else {
    say ">! Skipping rcfile write; attempting to use existing.";
  }
} else {
  RC_Write($relative_basedir);
}

my $rplvars = Conf_interactive();

Conf_write_confs($rplvars);

say ">! Finished.";

=pod

=head1 NAME

cobalt2-installer - install a cobalt2 instance

=head1 SYNOPSIS

B<cobalt2-installer> [ --rcfile=PATH ]

=head1 DESCRIPTION

A simple walk-through installer for the cobalt2 IRC bot.

Asks a few questions and copies initial confs and langsets to a specified 
directory, giving your cobalt2 bot a convenient home.

Typically you would run this installer before starting Cobalt:

  ## From a shell
  ## Build and install normally via build or makefile ...
  ~/cobalt2 $ perl Build.PL
  ~/cobalt2 $ perl Build && perl Build install
  ## Initiate a new cobalt2 instance
  ## Each instance has its own rcfile
  $ cobalt2-installer
  $ cobalt2

You can run multiple instances of Cobalt, but they each need their own 
I<etc> and I<var> directories, specified in their own rcfile:

  ## Initiate another cobalt2 instance
  $ cobalt2-installer --rcfile=${HOME}/cobalts/MyCobalt.rc
  $ cobalt2 --rcfile=${HOME}/cobalts/MyCobalt.rc

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

L<http://www.cobaltirc.org>

=cut
__DATA__
