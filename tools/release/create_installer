#!/usr/bin/env perl

## __DATA__ contains the actual src for cobalt2-installer.
##
## Walks a specified 'etc/examples' dir and builds a self-contained 
## install tool out of our __DATA__ and the found example config files.
##
## The resulting installer's own __DATA__ contains serialized versions of 
## example configuration files, which can be thawed and written back to 
## disk, possibly with templating.

use 5.12.1;
use strict;
use warnings;
use Carp;

use File::Find;
use File::Spec;

STDOUT->autoflush(1);

my $etcdir = qq{../../etc/examples};
my $file_out_path = qq{cobalt2-installer};

use Getopt::Long;
GetOptions(

  'help' => sub {
     print(
       "cobalt2 create_installer\n",
       " builds a standalone cobalt2-installer\n",
       "\n",
       "  -h | --help \n",
       "  -e | --etcdir=PATH  Specify path to etc/examples/ \n",
       "                      [$etcdir] \n",
       "  -o | --output=PATH  Specify path to output file \n",
       "                      [$file_out_path] \n",       
     );
     exit 0
   },


   'etcdir=s' => \$etcdir,
   'output=s' => \$file_out_path,

);

croak "not a dir: $etcdir" unless -d $etcdir;

## Determine which JSON module to use.
my @json_pref = qw/ JSON JSON::XS JSON::PP /;
for my $module (@json_pref) {
  eval "require $module";
  if ($@) {
    next ## No luck, try the next module
  } else {
    ## Import encode_json
    say "Using JSON module: $module";
    $module->import('encode_json');
    last
  }
}
croak "Did not find a JSON serializer" unless exists &encode_json;



## If we have 'JSON' it will do this for us:
eval "require JSON";
if ($@) {
  ## No JSON.pm, try JSON::XS ourselves:
  eval "require JSON::XS";
  if ($@) {
    ## Apparently no JSON::XS
    ## As of perl-5.14.1 JSON::PP is core
    ## Try JSON::PP:
    eval "require JSON::PP";
    if ($@) {
      ## No luck there either.
      croak "Did not find any usable JSON module";
    } else {
      JSON::PP->import('encode_json');
    }
  } else {
    JSON::XS->import('encode_json');
  }
} else {
  JSON->import('encode_json');
}

## Find example confs (.conf) and langs (.yml) in $etcdir:
my @valid_exts = qw/ conf cf yml yaml json /;
my @to_add;
## Search within an absolute path:
my $abs_etcdir = File::Spec->rel2abs($etcdir);
find(
  sub {
    my ($ext) = $_ =~ /\.(\S+)$/;
    return unless $ext ~~ @valid_exts;
    push @to_add, $File::Find::name;
  },
  $abs_etcdir
);

## Create hash keyed on relative-to-etcdir path
## Values are the contents of the files to pack to DATA:
my $pref = {};
for my $to_add_path (@to_add) {
  my $relative_path = File::Spec->abs2rel($to_add_path, $abs_etcdir);

  open(my $fh, '<', $to_add_path) or croak "open: $to_add_path: $!";
  my $slurped;
  {   local $/;   $slurped = <$fh>;   }
  close($fh) or warn "failed to close $to_add_path: $!";

  $pref->{$relative_path} = $slurped;
}

## Serialize to JSON
## JSON is used because it's:
##  (a) compact
##  (b) fast as hell (using JSON::XS)
##  (c) core (as of perl-5.14)
my $json = encode_json($pref);

## Save serialization to @installer's __DATA__

my @installer = <DATA>;
push(@installer,
    "\n",
    "__DATA__",
    $json
);

## The installer should read it back from its DATA, deserialize and write 
## back the example files
## FIXME use template::toolkit on the write back side
## then we can prompt for conf values and set UserConf or something appropriately for write

## The cobalt2-installer src follows.

__DATA__

#!/usr/bin/env perl

## cobalt2 installer generated by tools/release/create_installer
my $version = '0.10';

#FIXME follow pattern set forth in TODO

use 5.12.1;
use strict;
use warnings;
use Carp;
STDOUT->autoflush(1);

my $have_readkey;

use Getopt::Long;
GetOptions(
  'version' => sub {
    say "$0 $version";
    exit 0
  },
  'help' => \&helper,


);

sub helper {
  print(
    ## FIXME
  );
  exit 0
}

sub kit_check {
  say "> Checking your kit, one moment.";

  print "> Checking for Term::ReadKey . . . ";
  eval "require Term::ReadKey";
  if ($@) {
    $have_readkey and $have_readkey = 0;
    print(
      "No\n",
      ">! Did not find Term::ReadKey; cannot blank passwd prompts",
      "\n" 
    );
  } else {
    ++$have_readkey;
    Term::ReadKey->import('ReadMode');
    print "OK\n";
  }

}
