#!/usr/bin/env perl

## __DATA__ contains the actual src for cobalt2-installer.
##
## Walks a specified 'etc/examples' dir and builds a self-contained 
## install tool out of our __DATA__ and the found example config files.
##
## The resulting installer's own __DATA__ contains serialized versions of 
## example configuration files, which can be thawed and written back to 
## disk, possibly with templating.

use 5.12.1;
use strict;
use warnings;
use Carp;

use File::Find;
use File::Spec;

STDOUT->autoflush(1);

my $etcdir = qq{../../etc/examples};
my $outpath = qq{cobalt2-installer};

use Getopt::Long;
GetOptions(

  'help' => sub {
     print(
       "cobalt2 create_installer\n",
       " builds a standalone cobalt2-installer\n",
       "\n",
       "  -h | --help \n",
       "  -e | --etcdir=PATH  Specify path to etc/examples/ \n",
       "                      [$etcdir] \n",
       "  -o | --output=PATH  Specify path to output file \n",
       "                      [$outpath] \n",       
     );
     exit 0
   },


   'etcdir=s' => \$etcdir,
   'output=s' => \$outpath,

);

croak "not a dir: $etcdir" unless -d $etcdir;

## Determine which JSON module to use.
my @json_pref = qw/ JSON JSON::XS JSON::PP /;
for my $module (@json_pref) {
  eval "require $module";
  if ($@) {
    next ## No luck, try the next module
  } else {
    ## Import encode_json
    say "Using JSON module: $module";
    $module->import('encode_json');
    last
  }
}
croak "Did not find a JSON serializer" unless exists &encode_json;

## Find example confs (.conf) and langs (.yml) in $etcdir:
my @valid_exts = qw/ conf cf yml yaml json /;
my @to_add;
## Search within an absolute path:
my $abs_etcdir = File::Spec->rel2abs($etcdir);
find(
  sub {
    my ($ext) = $_ =~ /\.(\S+)$/;
    return unless $ext ~~ @valid_exts;
    push @to_add, $File::Find::name;
  },
  $abs_etcdir
);

## Create hash keyed on relative-to-etcdir path
## Values are the contents of the files to pack to DATA:
my $pref = {};
for my $to_add_path (@to_add) {
  my $relative_path = File::Spec->abs2rel($to_add_path, $abs_etcdir);

  open(my $fh, '<', $to_add_path) or croak "open: $to_add_path: $!";
  my $slurped;
  {  local $/;  $slurped = <$fh>;  }
  close($fh) or warn "failed to close $to_add_path: $!";

  $pref->{$relative_path} = $slurped;
}

## Serialize to JSON
## JSON is used because it's:
##  * compact
##  * fast as hell (using JSON::XS)
##  * core (as of perl-5.14)
my $json = encode_json($pref);

## Save serialization to @installer's __DATA__
my $installer;
{  local $/;  $installer = <DATA>;  }
$installer .= "\n" . '__DATA__' . $json;

## Write installer somewhere
say ">> Writing to $outpath";
say ">> Enter to continue, Ctrl+C to quit";
<STDIN>;
open(my $fh, '>', $outpath) or croak "open: $outpath: $!";
print $fh $installer;
close($fh) or warn "failed to close $outpath: $!";
carp "failed chmod 755 $outpath" unless chmod(755, $outpath);


######################################################################
######################################################################

## The installer should read it back from its DATA, deserialize and write 
## back the example files

## FIXME use template::toolkit on the write back side
## then we can prompt for conf values and set UserConf or something appropriately for write

######################################################################
## End of create_installer.
## The cobalt2-installer src follows.
######################################################################
__DATA__
#!/usr/bin/env perl
my $version = '0.10';
## cobalt2 installer generated by tools/release/create_installer
## assumes JSON is available (ie makefile has already been run)

#FIXME follow pattern set forth in TODO

use 5.12.1;
use strict;
use warnings;
use Carp;
use JSON;
STDOUT->autoflush(1);
my $rcfile = $ENV{HOME} . "/.cobalt2rc";
use Getopt::Long;
GetOptions(

  version => sub {
    say "$0 $version";
    exit 0
   },

  help => sub {
    print(
      "$0 $version\n\n",
      "Options:\n",
      "  -c, --rcfile=PATH    Path to cobalt2 rcfile\n",
      "                       [default: $rcfile]\n",
    );
    exit 0
   },

  'rcfile=s' => \$rcfile,
  'config=s' => \$rcfile,
);


## MAIN
say "> using rcfile: $rcfile";
kit_check();
if ( rc_check() ) {
  #FIXME found rcfile(?), rc_read(); -- validate or prompt / croak / something
} else {
  #FIXME rc_new();
}

#FIXME now we should have a rcfile
#FIXME confirm then print that to disk

sub write_confs {
  my ($ref, $root_path) = @_;
  return unless ref $ref eq 'HASH';
  for my $path (keys %$ref) {
    #FIXME
  }
}

sub deserialize_confs {
  my $json;
  {  local $/ ; $json = <DATA>;  }
  my $ref = decode_json $json;
  return ref $ref eq 'HASH' ? $ref : () ;
}

sub rc_check {
  unless (-e $rcfile) {
    say ">! $rcfile not found; assuming first run.\n";
    return
  } else {
    say "> found rcfile $rcfile\n";
    return 1
  }
}


sub kit_check {
  say "> Checking your kit, one moment.";

  print "> Checking for Term::ReadKey . . . ";
  eval "require Term::ReadKey";
  if ($@) {
    print(
      "failed\n",
      ">! Did not find Term::ReadKey; cannot blank passwd prompts",
      "\n" 
    );
  } else {
    Term::ReadKey->import('ReadMode');
    print "OK\n";
  }
}


sub _slurp {
  my ($path) = @_;
  my $str;
  open(my $fh, '<', $path) or croak "failed file read: $path: $!" ;
  {  local $/ ; $str = <$fh>;  }
  close($fh) or carp "failed to close $path: $!";
  return $str
}
