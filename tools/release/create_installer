#!/usr/bin/env perl

## __DATA__ contains the actual src for cobalt2-installer.
##
## Walks a specified 'etc/' dir and builds a self-contained 
## install tool out of our __DATA__ and the found example config files.
##
## The resulting installer's own __DATA__ contains serialized versions of 
## example configuration files, which can be thawed and written back to 
## disk, possibly with templating.

use 5.12.1;
use strict;
use warnings;
use Carp;

use File::Find;
use File::Spec;

STDOUT->autoflush(1);

my $etcdir = qq{etc};
my $outpath = qq{bin/cobalt2-installer};

use Getopt::Long;
GetOptions(

  'help' => sub {
     print(
       "cobalt2 create_installer\n",
       " builds a standalone cobalt2-installer\n",
       "\n",
       "  -h | --help \n",
       "  -e | --etcdir=PATH    Specify path to etc/ to pack \n",
       "                        [$etcdir] \n",
       "  -o | --output=PATH    Specify path to output file \n",
       "                        [$outpath] \n",       
     );
     exit 0
   },


   'etcdir=s' => \$etcdir,
   'output=s' => \$outpath,

);

croak "not a dir: $etcdir" unless -d $etcdir;

## Determine which JSON module to use.
my @json_pref = qw/ JSON JSON::XS JSON::PP /;
for my $module (@json_pref) {
  eval "require $module";
  if ($@) {
    next ## No luck, try the next module
  } else {
    ## Import encode_json
    say "Using JSON module: $module";
    $module->import('encode_json');
    last
  }
}
croak "Did not find a JSON serializer" unless exists &encode_json;

## Find example confs (.conf) and langs (.yml) in $etcdir:
my @valid_exts = qw/ conf cf yml yaml json /;
my @to_add;
## Search within an absolute path:
my $abs_etcdir = File::Spec->rel2abs($etcdir);
find(
  sub {
    my ($ext) = $_ =~ /\.(\S+)$/;
    return unless $ext ~~ @valid_exts;
    push @to_add, $File::Find::name;
  },
  $abs_etcdir
);

## Create hash keyed on relative-to-etcdir path
## Values are the contents of the files to pack to DATA:
my $pref = {};
for my $to_add_path (@to_add) {
  my $relative_path = File::Spec->abs2rel($to_add_path, $abs_etcdir);

  open(my $fh, '<', $to_add_path) or croak "open: $to_add_path: $!";
  my $slurped;
  {  local $/;  $slurped = <$fh>;  }
  close($fh) or warn "failed to close $to_add_path: $!";

  $pref->{$relative_path} = $slurped;
}

## Serialize to JSON
## JSON is used because it's:
##  * compact
##  * fast as hell (using JSON::XS)
##  * core (as of perl-5.14)
my $json = encode_json($pref);

## Save serialization to @installer's __DATA__
my $installer;
{  local $/;  $installer = <DATA>;  }
$installer .= "\n__DATA__\n" . $json;

## Write installer somewhere
say ">> Writing to $outpath";
say ">> Enter to continue, Ctrl+C to quit";
<STDIN>;
open(my $fh, '>', $outpath) or croak "open: $outpath: $!";
print $fh $installer;
close($fh) or warn "failed to close $outpath: $!";
carp "failed chmod 755 $outpath" unless chmod(0755, $outpath);

say ">> Done";

######################################################################
### End of create_installer.
### The cobalt2-installer src follows (in DATA handle)
######################################################################

__DATA__
#!perl
my $version = '0.12';

use 5.12.1;
use strict;
use warnings;
use Carp;

use File::Path;

use JSON;

use Cobalt::Utils qw/ rplprintf /;

STDOUT->autoflush(1);

my $rcfile = $ENV{HOME} . "/.cobalt2rc";

use Getopt::Long;
GetOptions(

  version => sub {
    say "$0 $version";
    exit 0
   },

  help => sub {
    print(
      "$0 $version\n\n",
      "Options:\n",
      "  -c, --rcfile=PATH    Path to cobalt2 rcfile\n",
      "                       [default: $rcfile]\n",
    );
    exit 0
   },

  'rcfile=s' => \$rcfile,
  'config=s' => \$rcfile,
);


sub _deserialize_etc {
  ## Pulls our /etc from our DATA handle
  my $json;
  {  local $/ ; $json = <DATA>;  }
  my $ref = decode_json $json; 
  return ref $ref eq 'HASH' ? $ref : () ;
}

sub _slurp {
  my ($path) = @_;
  ## Slurp a file
  my $str;
  open(my $fh, '<', $path) or croak "failed file read: $path: $!" ;
  {  local $/ ; $str = <$fh>;  }
  close($fh) or carp "failed to close $path: $!";
  return $str
}

sub _ans {
  ## f.ex: my $default_yes = _ans(my $in = <STDIN>, 'Y')
  my ($stdin, $default) = @_;
  chomp($stdin);
  $stdin = $stdin ? $stdin : $default ;
  return unless $stdin =~ /^Y/i;
}

## RC_* funcs
sub RC_Read {
  ## Read the current $rcfile
  my $str = _slurp($rcfile);
  my ($BASE, $ETC, $VAR);
  eval $str;
  if ($@) {
    croak "Errors reported during rc parsing; $@";
  }
  return ($BASE, $ETC, $VAR);
}

sub RC_Write {
  my ($relative_base) = @_;
  ## Pass me a base path relative to $ENV{HOME} such as 'cobalt2'
  ## Writes a basic cobalt2rc to current value of $rcfile
  my $str = join "\n",
    '## cobalt2rc automatically generated at '.scalar localtime,
    '$BASE = $ENV{HOME} . "/'.$relative_base.'";' ,
    '$ETC = $BASE . "/etc";' ,
    '$VAR = $BASE . "/var";' ,
  ;

  open(my $fh, '>', $rcfile)
    or croak "failed to open $rcfile: $!";
  print $fh $str;
  close($fh) or carp "close failed for $rcfile: $!";

  say ">! wrote rcfile";
  say ">! ETC is: ". $ENV{HOME} ."/". $relative_base . "/etc" ;
  say ">! VAR is: ". $ENV{HOME} ."/". $relative_base . "/var" ;
  say ">! To change, edit $rcfile\n";
}


## Conf_* funcs

sub Conf_write_confs {
  ## Conf_write_confs($vars_replacement_hash)
  my ($vars_h) = @_;
  my ($base, $etc, $var) = RC_Read();
  File::Path::mkpath( $var );
  my $ref = _deserialize_etc();
  ## should have a vars hash for rplprintf, and RC_Read can give us an etc dir path
  ## use File::Path to create our dir structure
  ## write our deserialized confs back out
  ## run rplprintf against each file before writing
  for my $confpath (keys %$ref) {

    my $output_path = $etc ."/". $confpath ;
    (undef, my $dir, my $file) = File::Spec->splitpath($output_path);
    File::Path::mkpath($dir) if $dir;
    croak "tried to create $dir but can't be found?" unless -e $dir;

    my $content = $ref->{$confpath};
    my $output = rplprintf( $content, $vars_h );

    say ">! Attempting to write $output_path . . .";

    if (-e $output_path) {
      say ">! Exists already: $output_path";
      print "Should I overwrite it? [y/N] ";
      if ( _ans(my $in = <STDIN>, 'N') ) {
        say ">! Overwriting $output_path";
      } else { next }
    }

    open(my $fh, '>', $output_path) or croak "open failed: $output_path: $!";
    print $fh $output;
    close($fh) or carp "close failed on $output_path: $!";

    say ">! Wrote $confpath";
  }

  say ">! Finished writing confs.";
}


sub Conf_interactive {
  my $cf = {};

  print(
    "Interactively configuring basic cobalt2 opts.\n",
    "This installer only covers the most basic set of options.\n",
    "You should review etc/ yourself when finished.\n\n",
    "Defaults are shown [like this]\n\n",
  );

  say ">! Configuring cobalt.conf";

  print "Bot's nickname [cobalt2] ";
  $cf->{CFG_BOT_NICK} = <STDIN>;
  chomp $cf->{CFG_BOT_NICK} ;
  $cf->{CFG_BOT_NICK} ||= 'cobalt2';

  print "Bot's username [cobalt] ";
  $cf->{CFG_BOT_USERNAME} = <STDIN>;
  chomp $cf->{CFG_BOT_USERNAME} ;
  $cf->{CFG_BOT_USERNAME} ||= 'cobalt';

  print "Bot's 'realname' [cobalt2 bot] ";
  $cf->{CFG_BOT_REALNAME} = <STDIN>;
  chomp $cf->{CFG_BOT_REALNAME} ;
  $cf->{CFG_BOT_REALNAME} ||= 'cobalt2 bot';

  print "Remote ServerAddr [irc.cobaltirc.org] ";
  $cf->{CFG_SERVER_ADDR} = <STDIN>;
  chomp $cf->{CFG_SERVER_ADDR} ;
  $cf->{CFG_SERVER_ADDR} ||= 'irc.cobaltirc.org';

  print "Use SSL for this server? [y/N] ";
  my $usessl = _ans(my $in = <STDIN>, 'n');
  $cf->{CFG_USE_SSL} = $usessl ? 1 : 0 ;

  my $default_irc_port = $usessl ? 6697 : 6667 ;
  print "Remote port [$default_irc_port] ";
  $cf->{CFG_SERVER_PORT} = <STDIN>;
  chomp $cf->{CFG_SERVER_PORT} ;
  $cf->{CFG_SERVER_PORT} ||= $default_irc_port;

  say "You need to specify a command character for the bot.";
  say "This is used to prefix various plugin-provided commands.";
  print "Bot's command character [ ! ] ";
  $cf->{CFG_CMD_CHAR} = <STDIN>;
  chomp $cf->{CFG_CMD_CHAR};
  $cf->{CFG_CMD_CHAR} ||= '!' ;

  say ">! Done configuring cobalt.conf" ;
  say ">! There are many more opts; review the file!";

  # plugins.conf is probably fine with a suitable example file
  
  say ">! Configuring channels.conf";
  say "You're going to want to set up an initial channel.";

  print "Channel name [#otw] ";
  $cf->{CHAN} = <STDIN>;
  chomp $cf->{CHAN};
  $cf->{CHAN} ||= '#otw';

  ## FIXME ChanMgr?
  say "You may want to edit channels.conf and add other channels.";

  say ">! Configuring auth.conf";
  ## FIXME


  return $cf
}


## MAIN
print(
  "This is the cobalt2 install helper.\n",
  "This script will create a cobalt2rc file specifying install paths.\n",
  "It will also help you initialize some starter cobalt2 conf files.\n",
  "> Press ENTER to continue, Ctrl+C to quit.",
);
<STDIN>;

say "> Default rcfile: $rcfile";

## prompt user for a rcfile path
print "> Enter a different rcfile location? [y/N] ";
if ( _ans(my $in = <STDIN>, 'N') ) {
  do {
    print "> Path to rcfile: ";
    $rcfile = <STDIN>; chomp($rcfile);
  } until $rcfile;
}

say ">! using rcfile: $rcfile";

## prompt user for a relative basedir
say "> Cobalt needs a place for etc/ and var/ to live.";
say "> Normally this would be somewhere in your HOME directory.";
say "> Specify a directory relative to your HOME for cobalt to live:";
print "[cobalt2] ";
my $relative_basedir = <STDIN> ; chomp($relative_basedir);

if (-e $rcfile) {
  say ">! $rcfile seems to already exist.";
  say ">! Should I overwrite it? [y/N] ";
  if ( _ans(my $in = <STDIN>, 'N') ) {
    RC_Write($relative_basedir);
  } else {
    say ">! Skipping rcfile write; attempting to use existing.";
  }
} else {
  RC_Write($relative_basedir);
}

my $rplvars = Conf_interactive();

Conf_write_confs($rplvars);

say ">! Finished.";

=pod

=head1 NAME

cobalt2-installer - install a cobalt2 instance

=head1 SYNOPSIS

B<cobalt2-installer> [ --rcfile=PATH ]

=head1 DESCRIPTION

A simple walk-through installer for the cobalt2 IRC bot.

Asks a few questions and copies initial confs and langsets to a specified 
directory, giving your cobalt2 bot a convenient home.

Typically you would run this installer before starting Cobalt:

  ## From a shell
  ## Build and install normally via build or makefile ...
  ~/cobalt2 $ perl Build.PL
  ~/cobalt2 $ perl Build && perl Build install
  ## Initiate a new cobalt2 instance
  ## Each instance has its own rcfile
  $ cobalt2-installer
  $ cobalt2

You can run multiple instances of Cobalt, but they each need their own 
I<etc> and I<var> directories, specified in their own rcfile:

  ## Initiate another cobalt2 instance
  $ cobalt2-installer --rcfile=${HOME}/cobalts/MyCobalt.rc
  $ cobalt2 --rcfile=${HOME}/cobalts/MyCobalt.rc

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

L<http://www.cobaltirc.org>

=cut
