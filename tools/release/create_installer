#!/usr/bin/env perl

## __DATA__ contains the actual src for cobalt2-installer.
##
## Walks a specified 'etc/examples' dir and builds a self-contained 
## install tool out of our __DATA__ and the found example config files.
##
## The resulting installer's own __DATA__ contains serialized versions of 
## example configuration files, which can be thawed and written back to 
## disk, possibly with templating.

use 5.12.1;
use strict;
use warnings;
use Carp;

use File::Find;
use File::Spec;

STDOUT->autoflush(1);

my $etcdir = qq{../../etc/examples};
my $outpath = qq{cobalt2-installer};

use Getopt::Long;
GetOptions(

  'help' => sub {
     print(
       "cobalt2 create_installer\n",
       " builds a standalone cobalt2-installer\n",
       "\n",
       "  -h | --help \n",
       "  -e | --etcdir=PATH  Specify path to etc/examples/ \n",
       "                      [$etcdir] \n",
       "  -o | --output=PATH  Specify path to output file \n",
       "                      [$outpath] \n",       
     );
     exit 0
   },


   'etcdir=s' => \$etcdir,
   'output=s' => \$outpath,

);

croak "not a dir: $etcdir" unless -d $etcdir;

## Determine which JSON module to use.
my @json_pref = qw/ JSON JSON::XS JSON::PP /;
for my $module (@json_pref) {
  eval "require $module";
  if ($@) {
    next ## No luck, try the next module
  } else {
    ## Import encode_json
    say "Using JSON module: $module";
    $module->import('encode_json');
    last
  }
}
croak "Did not find a JSON serializer" unless exists &encode_json;

## Find example confs (.conf) and langs (.yml) in $etcdir:
my @valid_exts = qw/ conf cf yml yaml json /;
my @to_add;
## Search within an absolute path:
my $abs_etcdir = File::Spec->rel2abs($etcdir);
find(
  sub {
    my ($ext) = $_ =~ /\.(\S+)$/;
    return unless $ext ~~ @valid_exts;
    push @to_add, $File::Find::name;
  },
  $abs_etcdir
);

## Create hash keyed on relative-to-etcdir path
## Values are the contents of the files to pack to DATA:
my $pref = {};
for my $to_add_path (@to_add) {
  my $relative_path = File::Spec->abs2rel($to_add_path, $abs_etcdir);

  open(my $fh, '<', $to_add_path) or croak "open: $to_add_path: $!";
  my $slurped;
  {  local $/;  $slurped = <$fh>;  }
  close($fh) or warn "failed to close $to_add_path: $!";

  $pref->{$relative_path} = $slurped;
}

## Serialize to JSON
## JSON is used because it's:
##  * compact
##  * fast as hell (using JSON::XS)
##  * core (as of perl-5.14)
my $json = encode_json($pref);

## Save serialization to @installer's __DATA__
my $installer;
{  local $/;  $installer = <DATA>;  }
$installer .= "\n__DATA__\n" . $json;

## Write installer somewhere
say ">> Writing to $outpath";
say ">> Enter to continue, Ctrl+C to quit";
<STDIN>;
open(my $fh, '>', $outpath) or croak "open: $outpath: $!";
print $fh $installer;
close($fh) or warn "failed to close $outpath: $!";
carp "failed chmod 755 $outpath" unless chmod(0755, $outpath);

say ">> Done";

######################################################################
######################################################################

## The installer should read it back from its DATA, deserialize and write 
## back the example files

## FIXME use template::toolkit on the write back side
## then we can prompt for conf values and set UserConf or something appropriately for write

######################################################################
## End of create_installer.
## The cobalt2-installer src follows.
######################################################################
__DATA__
#!/usr/bin/env perl
my $version = '0.10';
## cobalt2 installer generated by tools/release/create_installer
## assumes JSON is available (ie makefile has already been run)

use 5.12.1;
use strict;
use warnings;
use Carp;
use JSON;

STDOUT->autoflush(1);

my $rcfile = $ENV{HOME} . "/.cobalt2rc";

use Getopt::Long;
GetOptions(

  version => sub {
    say "$0 $version";
    exit 0
   },

  help => sub {
    print(
      "$0 $version\n\n",
      "Options:\n",
      "  -c, --rcfile=PATH    Path to cobalt2 rcfile\n",
      "                       [default: $rcfile]\n",
    );
    exit 0
   },

  'rcfile=s' => \$rcfile,
  'config=s' => \$rcfile,
);


## MAIN
print(
  "This is the cobalt2 install helper.\n",
  "This script will create a cobalt2rc file specifying install paths.\n",
  "It will also help you initialize some starter cobalt2 conf files.\n",
  "> Press ENTER to continue, Ctrl+C to quit.\n",
);
<STDIN>;

say "> using rcfile: $rcfile";

kit_check();

my ($base, $etc, $var);

if ( rc_check() ) { 
  ## rcfile exists, try to read it in
  ($base, $etc, $var) = rc_read();
} else {
  ## doesn't exist, try to write one
  rc_new();
  ## then read it back in
  ($base, $etc, $var) = rc_read();
}


unless ($etc) {
  say ">! We have a cobalt2rc, but ETC is not set.";
  say ">! Check your rcfile: $rcfile";
  croak "no ETC specified";
}

unless ($var) {
  say ">! We have a cobalt2rc, but VAR is not set.";
  say ">! Check your rcfile: $rcfile";
  croak "no VAR specified";
}

## FIXME cf_check to see if these dirs exist and if etc contains confs already
# if core confs exist, offer to move them and write new ones or quit
# if not, write new ones (with templates?)

## Fetch confs from <DATA>
my $confs_r = deserialize_confs();

write_confs($confs_r, $base);

say ">> Done.";

sub _ans {
  my ($stdin, $default) = @_;
  chomp($stdin);
  $stdin = $stdin ? $stdin : $default ;
  return unless $stdin =~ /^Y/i;
}

sub write_confs {
  my ($ref, $root_path) = @_;
  return unless ref $ref eq 'HASH';
  for my $path (keys %$ref) {
    #FIXME
    # if the path exists, prompt user for what to do

    # 
  }
}

sub check_for_existing_cf {
  ## called by write_confs for each path
  ## if the file exists, prompt user for what to do, act accordingly
}

sub check_for_path {
  ## called by write_confs for each path
  ## if the preceeding dir structure doesn't exist, try to create it
}

sub configure_myself {
  ## prompt user for common conf opts
  ## set up template vars appropriately
}

sub template_conf {
  ## called by write_confs
  ## process a conf template
}

sub deserialize_confs {
  my $json;
  {  local $/ ; $json = <DATA>;  }
  my $ref = decode_json $json;
  return ref $ref eq 'HASH' ? $ref : () ;
}

sub rc_new {
  # prompt user and create new cobalt2rc
  # confirm and write to disk

  say ">! Attempting to create rcfile: $rcfile";
  say ">! The rcfile tells cobalt2 where to find its ETC and VAR directories.";
  say ">! The default is to select a directory under your HOME.";
  say ">! You can change this later by editing the rcfile, if you like.";

  my $default_relative_base = 'cobalt2';

  say ">! ENTER to use the default, or a directory relative to HOME:";
  say "> Path: [$default_relative_base] ";
  my $relative_base = <STDIN> ; chomp($relative_base) ;
  $relative_base = $relative_base ? $relative_base : $default_relative_base ;

  my $str = join "\n",
    '## cobalt2rc automatically generated at '.scalar localtime,
    '$BASE = $ENV{HOME} . "/'.$relative_base.'";' ,
    '$ETC = $BASE . "/etc";' ,
    '$VAR = $BASE . "/var";' ,
  ;

  open(my $fh, '>', $rcfile)
    or croak "failed to open $rcfile: $!";

  print $fh $str;

  close($fh) or carp "close failed for $rcfile: $!";

  say ">! wrote rcfile";
  say ">! ETC is: ". $ENV{HOME} ."/". $relative_base . "/etc" ;
  say ">! VAR is: ". $ENV{HOME} ."/". $relative_base . "/var" ;
  say ">! To change, edit $rcfile";
}

sub rc_read {
  # read in an existing cobalt2rc
  my $str = _slurp($rcfile);
  my ($BASE, $ETC, $VAR);
  eval $str;
  if ($@) {
    croak "Errors reported during rc parsing; $@";
  }
  ## my ($base, $etc, $var) = rc_read()
  return ($BASE, $ETC, $VAR);
}

sub cf_check {
  # FIXME we know where to look for confs, now see if we have core confs
  # if not, call cf_write
}

sub cf_write {
  # create dir structure as-needed
  # write out confs
  # prompt for common config values and use template?
}

sub rc_check {
  unless (-e $rcfile) {
    say ">! $rcfile not found; assuming first run.\n";
    return
  } else {
    say "Found rcfile $rcfile\n";
    return 1
  }
}


sub kit_check {
  say "Checking your kit, one moment.";
  print "Checking for Term::ReadKey . . . ";
  eval "require Term::ReadKey";
  if ($@) {
    print(
      "failed\n",
      ">! Did not find Term::ReadKey; cannot blank passwd prompts",
      "\n" 
    );
  } else {
    Term::ReadKey->import('ReadMode');
    print "OK\n";
  }
}


sub _slurp {
  my ($path) = @_;
  my $str;
  open(my $fh, '<', $path) or croak "failed file read: $path: $!" ;
  {  local $/ ; $str = <$fh>;  }
  close($fh) or carp "failed to close $path: $!";
  return $str
}
