#!/usr/bin/env perl
my $VERSION = '0.10';

## ugly little release tool for my own purposes ...
## walk cobalt/doc looking for .pm/.pod
## create dokuwiki files for publishing online, or specified format
## accepts types: doku, text, html
## index templates live in indexes/

use 5.12.1;
use strict;
use warnings;
use Carp;

use YAML::Syck;

use File::Basename;
use File::Path;
use File::Slurp qw/read_file write_file/;
use File::Spec;

use Pod::Find qw/pod_find contains_pod/;

use CobaltdocToDoku;

use Template;  ## templatable indexes

my $conffile = qq{cfg-docs.yml};
my $destdir  = qq{wikidoc};
my $indexdir = qq{indexes};
my $outtype  = qq{doku};

## $index_items is a hashref to feed tt and build simple indexes
## indexed by header/category
## each category is an array of items to add to the index
## $CATEGORY = [
##  {
##    Title => $title   ## f.ex 'Cobalt::Utils'
##    # html / doku / etc:
##    # Link root and target for this item
##    # Usually determined based on LINKROOT in cfg-docs.yml
##    Link => $link     ## f.ex 'cobalt:doc:Cobalt:Utils'
##  },
##  ...
## ],
my $index_items = { };

use Getopt::Long;
GetOptions(
  help => \&show_help,
  version => sub { say "$0 $VERSION" ; exit 1 },

  'config=s'  => \$conffile,
  'type=s'    => \$outtype,
  'destdir=s' => \$destdir,
  'indexes=s' => \$indexdir,
);

sub show_help {
  print(
    "cpodconv -- walk configured dirs, turn POD into other formats\n",
    "intended for cobalt2 releases and doc updates\n\n",
    "  --config=PATH   Path to YAML config file [def.: $conffile]\n",
    "  --type=TYPE     Type of output [def.: $outtype]\n",
    "  --indexes=PATH  Path to dir containing index-TYPE.tt",
                       " [def.: $indexdir]\n",
    "  --dest=PATH     Path to destination dir [def.: $destdir]\n",
  );
  exit 1
}

croak "could not locate cfg: $conffile" unless -f $conffile;

my $cfg = LoadFile( $conffile );

my $rootdir = $cfg->{OPTS}->{ROOT} // croak("cfg; OPTS->ROOT missing?");
my $docmaps = ref $cfg->{MAP} ? $cfg->{MAP} : croak("cfg; MAP-> missing?");

croak "err; ROOT [$rootdir] missing or not a directory" unless -d $rootdir;
croak "err; Map directive contains no keys" unless scalar keys %$docmaps;

unless (-d $destdir) {
  croak "destdir [$destdir] exists but not a directory" if -e $destdir;
  say "destdir [$destdir] nonexistant, creating it";
  mkdir $destdir;
}

my $dochash = {};

for my $rootname (sort keys %$docmaps) {  ## 'Cobalt', 'Manual', ...
  my $relative = $docmaps->{$rootname}->{DIR}
    // croak "missing DIR in $rootname" ;

  my $dir_fullpath = $rootdir . "/" . $relative ;

  unless (-d $dir_fullpath) {
    say "Skipping $rootname, path [$dir_fullpath] not found";
    next
  }

  ## if SLURP_ALL is specified, read all PODs we can find
  ## else check for specific FILES
  my @podpaths;
  if ($docmaps->{$rootname}->{SLURP_ALL}) {

    my %pods = pod_find( {}, $dir_fullpath );
    push(@podpaths, map { File::Spec->rel2abs($_) } keys %pods);

    for my $filepath (@podpaths) {
      ## operating on a full path to a found POD
      ## get the name relative to dir_fullpath:
      my $basename = File::Spec->abs2rel($filepath, $dir_fullpath);
      ## now we should have something like:
      ## lib/Cobalt/IRC.pm -> 'IRC.pm'
      ## lib/Cobalt/Plugin/Auth.pm -> 'Plugin/Auth.pm'
      ## turn it into something like "Cobalt::IRC":
      $basename = basename($basename, '.pm', '.pod');
      ## array for building relative links:
      my @split = split /\//, $basename;
      unshift(@split, $rootname);
      $basename =~ s@/@::@g;
      my $pod_name = $rootname .'::'. $basename;
      ## now we have a full path and a label

      ## add to index:
      my $linkroot = $cfg->{OPTS}->{PARSER}->{$outtype}->{LINKROOT} // '';
      my $sep;
      given ($outtype) {
        $sep = ':' when "doku";
        default { $sep = '/'; }
      }
      push( @{ $index_items->{$rootname} },
        {
           Title => $pod_name,
           Link => $linkroot . join($sep, @split),
        },
      );

      my($ext, $parsed);
      given ($outtype) {
        when ("doku") {
          $parsed = pod_to_doku($filepath);
          $ext = ".txt";
        }

        when ("txt") {
          $parsed = pod_to_text($filepath);
          $ext = '.txt';
        }

      }

      ## see if our destdir exists:
      my $name = pop @split;
      my $out_path;
      if ($outtype eq 'doku') {
        $out_path = $destdir . "/". join("/", map { lc($_) } @split);
        $name = lc($name);
      } else {
        $out_path = $destdir . "/". join("/", @split) ;
      }
      File::Path::make_path($out_path) unless -d $out_path;
      
      ## piece together output path:
      if ($outtype eq 'doku') {
        $out_path = $destdir ."/". join("/", map { lc($_) } @split) ."/". $name . $ext;
      } else {
        $out_path = $destdir ."/". join("/", @split) ."/". $name . $ext;
      }

      ## try to write converted file:
      say "Writing: $out_path";
      write_file( $out_path, $parsed );      
    }

  } elsif (@{ $docmaps->{$rootname}->{FILES}//[] }) {

    for my $specified (@{ $docmaps->{$rootname}->{FILES} }) {
      my $path_to_file = $dir_fullpath . "/" . $specified;

      if ( contains_pod($path_to_file) ) {
        push(@podpaths, File::Spec->rel2abs($path_to_file) );
      } else {
        say "filepath $path_to_file in FILES but no POD?";
        next
      }
    ## FIXME

    }

  } else {
   say "Skipping $rootname, no files specified";
   next
  }
}

if (ref $cfg->{Extras}) {
  for my $item_name (keys %{ $cfg->{Extras} }) {
    my $in_path = $cfg->{OPTS}->{ROOT} ."/". $cfg->{Extras}->{$item_name}->{IN};

    unless (-f $in_path) {
      carp "extra file $in_path specified but not found";
      next 
    }

    unless ( contains_pod($in_path) ) {
      carp "extra file $in_path specified but no POD in document";
      next
    }

    my $relative_out = $cfg->{Extras}->{$item_name}->{OUT};
    my $linksep = '/';
    my($ext, $parsed, $out_path);
    given ($outtype) {
      
      when ("doku") {
        $relative_out = lc $relative_out;
        $linksep = ':' ;
        $ext = '.txt';
        $parsed = pod_to_doku($in_path);
      }

      when ("txt") {
        $ext = '.txt';
        $parsed = pod_to_text($in_path);
      }

    }

   if ($parsed) {
     my $full_out = $destdir . "/" . $relative_out . $ext;
     write_file($full_out, $parsed);
   } else {
     carp "parser ran but $parsed empty for item $item_name";
     next
   }

   my @split = split /\//, $cfg->{Extras}->{$item_name}->{OUT};
   my $linkroot = $cfg->{OPTS}->{PARSER}->{$outtype}->{LINKROOT} // '';
    ## add to index under 'Other'
   push( @{ $index_items->{Other} },
          {
             Title => $item_name,
             Link => $linkroot . join($linksep, @split),
          },
   );
 

  }
}

if ($cfg->{OPTS}->{PARSER}->{$outtype}->{INDEXFILE}) {
  ## Attempt to write an index
  my $tmpl_vars = { IndexItems => $index_items };
  my $index_content = parse_index($tmpl_vars) 
    if scalar keys $index_items;
  my $index_out_path = $destdir ."/". 
    $cfg->{OPTS}->{PARSER}->{$outtype}->{INDEXFILE};
  if ($index_content) {
    say "Writing index . . .";
    write_file($index_out_path, $index_content);
  } else {
    carp "Empty index_content?";
  }
}


sub parse_index {
  my ($vars) = @_;
  ## read/parse TT index files
  my $index_path = $indexdir ."/". "index-". $outtype . ".tt";
  unless (-f $index_path) {
    say "No index generated for $outtype; $index_path not found";
    return
  }
  my $tt = Template->new( { EVAL_PERL => 1, } );
  my $tmpl = read_file($index_path);
  my $out;
  $tt->process(\$tmpl, $vars, \$out);

  unless ($out) {
    carp "parsed index came out blank?";
    return
  }
  return $out;
}

sub pod_to_doku {
  my ($path) = @_;
  my $parser = CobaltdocToDoku->new;
  my $out;
  $parser->output_string( \$out );
  $parser->parse_file( $path );
  return $out
}


sub pod_to_text {
  my ($path) = @_;
  require Pod::Text;
  my $parser = Pod::Text->new;
  my $out;
  $parser->output_string( \$out );
  $parser->parse_file( $path );
  return $out
}


sub pod_to_html {
  my ($path) = @_;
  my $out;
  return $out
}
