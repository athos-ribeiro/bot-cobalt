#!/usr/bin/env perl
# Cobalt tools/mkpasswd
# bcrypt-enabled mkpasswd

use 5.10.0;
use strict;
use warnings;

use Time::HiRes qw/ gettimeofday tv_interval /;

my $type = 'bcrypt';
my $bcrypt_cost = '08';
my $showtimer = 0;
use Getopt::Long;
GetOptions(
  'method=s' => \$type,
  'workcost=s' => \$bcrypt_cost,
  'benchmark!' => \$showtimer,

  'help' => sub {
    print(
      "Cobalt mkpasswd\n",
      "Opts:\n",
      " --benchmark\n",
      "   Show timers. [Default: off]\n",
      "\n",
      " --method=<TYPE>\n",
      "   Default: -m bcrypt\n",
      "   Types: \n",
      "   - bcrypt (requires Crypt::Eksblowfish)\n",
      "   - sha256 (requires glibc2.7+)\n",
      "   - sha512 (requires glibc2.7+)\n",
      "   - md5 (fast, portable, insecure)\n",
      "\n",
      " bcrypt-only:\n",
      " --workcost=<two digit power of 2>\n",
      "   Default: -w 08\n",
      "   bcrypt work cost factor; higher is slower.\n",
      "   When it comes to comparing passwds, slower can be better.\n",
      "   See http://codahale.com/how-to-safely-store-a-password/\n",
    );
    exit 0
  },  
);
my $pwd;
if (@ARGV) {
  $pwd = $ARGV[0];
} else {
  print "Password: ";
  $pwd = <STDIN>;
  chomp($pwd);
}
my $timer0 = [gettimeofday()];
say pwd_generate($pwd);
my $interval0 = tv_interval($timer0);
say " bench: $type, timer0 -> $interval0" if $showtimer;

## from Circe:
sub pwd_generate {
  my $pwd = shift || return;
  my @p = ('a' .. 'z', 'A' .. 'Z', 0 .. 9, '_',);
  my $salt = join '', map { $p[rand@p] } 1 .. 8;
  given ($type)
  {
    when (/sha-?512/i) {  ## SHA-512: glibc-2.7+
      ## unfortunately mostly only glibc has support in crypt()
      ## SHA has variable length salts (up to 16)
      ## varied salt lengths can (maybe) slow down attacks
      ## (so says Drepper, anyway)
      $salt .= $p[rand@p] for 1 .. rand 8;
      $salt = '$6$'.$salt.'$';
    }

    when (/sha-?256/i) {  ## SHA-256: glibc-2.7+
      $salt .= $p[rand@p] for 1 .. rand 8;
      $salt = '$5$'.$salt.'$';
    }

    when (/^bcrypt$/i) {  ## Bcrypt: requires Crypt::Eksblowfish
      ## blowfish w/ cost factor
      eval { require Crypt::Eksblowfish::Bcrypt; };
      my $have_bcrypt = $@ ? 0 : 1;
      unless ($have_bcrypt) {
        say("WARNING: Attempting to use bcrypt but missing Crypt::Eksblowfish");
        say("WARNING: Defaulting to MD5 instead . . . !");
        $salt = '$1$'.$salt.'$';  ## no bcrypt here, generate md5 instead (sadface)
      } else {
        ## cost value is configurable, but 08 is a good choice.
        ## has to be a two digit power of 2. pad with 0 as needed
        my $cost = $bcrypt_cost // '08';
        ## bcrypt expects 16 octets of salt:
        $salt = join('', map { chr(int(rand(256))) } 1 .. 16);
        ## ...base64-encoded via bcrypt's en_base64:
        $salt = Crypt::Eksblowfish::Bcrypt::en_base64( $salt );
        ## actual settings string to feed bcrypt ($2a$COST$SALT)
        $salt = join('', '$2a$', $cost, '$', $salt);
        return Crypt::Eksblowfish::Bcrypt::bcrypt($pwd, $salt)
      }
    } 

    when ("DES") {
      ## not documented because it's a Very Bad Idea ...
      ## but here in case you're stuck with the world's worst crypt()
      ## srsly though, don't use it. no, really, the 80s are over, promise.
      $salt = join '', map { $p[rand@p] } 1..2;
    }

    default {  ## defaults to MD5 -- portable, fast, but weak
      $salt = '$1$'.$salt.'$';
    }
  }
  my $crypt = crypt($pwd, $salt);
  return $crypt
}



=pod

=head1 NAME

 mkpasswd

=head1 DESCRIPTION

  bcrypt-enabled mkpasswd

=head1 USAGE

 mkpasswd [OPTIONS]... [PASSWD]

=head1 OPTIONS

 -h, --help

 -b, --benchmark
     Show timers.

 -m, --method <TYPE>
     crypt method.
     Types:
       bcrypt (default; requires Crypt::Eksblowfish)
       sha512 (requires glibc2.7+)
       sha256 (requires glibc2.7+)
       md5 (fast, portable, weak)

 -w, --workcost <COST>
     bcrypt-only.
     Specify a work cost factor. Higher is slower.
     Must be a two-digit power of 2.
     Pad with zeros as necessary.

=head1 BCRYPT

While SHA512 isn't a bad choice if you have it, bcrypt has the 
advantage of including a configurable work cost factor.

A higher work cost factor exponentially increases hashing time.

That means it takes significantly longer to compare a very large 
number of passwords against yours.

=head1 AUTHOR

http://www.cobaltirc.org

=cut
