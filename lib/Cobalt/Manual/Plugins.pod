=pod

=head1 NAME

Cobalt::Manual::Plugins - Cobalt2 plugin-writing fundamentals guide

=head1 VERSION

Plugins guide revision: 0006

Last updated for cobalt 2.00_09

=head1 DESCRIPTION

This POD attempts to be a reasonably complete guide to writing useful 
B<Cobalt2> plugins.

Refer to L</SEE ALSO> for other relevant documentation.

B<Plugin authors should at least read the L<Cobalt::IRC> POD>


=head1 PLUGIN FUNDAMENTALS

=head2 Module paths and configuration

=head3 plugins.conf

Plugins specified in plugins.conf (located in our etc/) will be 
automatically loaded at runtime.

C<plugins.conf> is YAML in the following structure:

  ---
  MyPlugin:
    Module: Cobalt::Plugin::User::MyPlugin
    Config: plugins/mine/myplugin.conf
    ## Optional:
    Opts:
      Level: 2

Configuration files specified in 'Config: ' are expected to be valid 
B<YAML1.0>. You can read all about YAML at L<http://www.yaml.org> -- 
for the most part, YAML is fairly self-explanatory.
See L<Cobalt::Manual::PluginConf> for more about YAML and plugin configs.

They'll be automatically loaded at run-time; the data structure loaded 
will be stored in the core B<cfg> attribute, keyed by the plugin's 
package name.

Simple plugins might only need one or two config options; in this case, 
you can specify a B<Opts:> directive. It should be a hash (or a list, 
in very odd cases).

If an Opts: directive is supplied, it will be loaded into 
'cfg->{plugin_cf}->{$pkg}->{PluginOpts}'. See below.


=head3 Accessing plugin configuration

Typically, a plugin's configuration is loaded into memory and stored 
in the Core C<cfg> attribute.

The normal way to access a plugin's configuration structure is via the 
core method B<get_plugin_cfg>:

  ## Our __PACKAGE__ must be specified:
  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ );
  unless ($plug_cf) {
    ## No configuration found for our plugin ...
  }

FIXME examples

FIXME discussion about PluginOpts

FIXME discussion about direct access

See also: L</"Core methods">



=head2 A basic plugin outline

  package Cobalt::Plugin::User::MyPlugin;
  our $VERSION = '0.001';
  use strict;
  use warnings;
  
  ## You need Object::Pluggable::Constants in order to return valid
  ## pipeline control values, else you might break some or all plugins.
  ##
  ## See "Returning proper values" under "Handling events" in this POD.
  ## 
  ## PLUGIN_EAT_NONE is the most common.
  ##
  ## importing :ALL will give you all of them:
  use Object::Pluggable::Constants qw/ :ALL /;
  
  ## Cobalt::Utils provides many useful methods:
  use Cobalt::Utils qw/ :ALL /;
  
  ## minimalist object constructor:
  sub new { bless( {}, shift ) }
  
  ## called when we are loaded:
  sub Cobalt_register {
    ## handlers receive $self and $core as first two args:
    ## $self is "this object"
    ## $core gives us access to core attributes and methods:
    my ($self, $core) = @_;
    
    ## register to only receive public msg events:
    $core->plugin_register( $self, 'SERVER',
      [ 'public_msg' ]
    );
    
    ## log that we're here now:
    $core->log->info("Registered");

    ## we could save $core to $self->{core} to make life easier 
    ## on our internal methods, perhaps:
    $self->{core} = $core;
    
    ## ALWAYS return an Object::Pluggable::Constants value:
    return PLUGIN_EAT_NONE
  }
  
  ## called when we are unloaded:
  sub Cobalt_unregister {
    my ($self, $core) = @_;
    ## . . . do some clean up, perhaps . . .
    $core->log->info("Unregistering; bye!");
    return PLUGIN_EAT_NONE
  }
  
  ## Syndicated events become prefixed with 'Bot_'
  ## (when called send_event, leave the prefix out)
  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = $$_[0];
    my $msghash = $$_[1];
    ...
  }
  
  1;  ## perl modules must end in '1;'
  


=head2 Handling events

Plugins are fundamentally event driven.

A plugin will (usually at load-time) register to receive some set of 
events, which are pushed through the pipeline by the Cobalt core (with 
help from L<POE::Component::Syndicator> and L<Object::Pluggable>).

If your plugin needs to have a certain priority in the pipeline, you're 
going to want to spend some quality time reading the L<Object::Pluggable> 
and especially L<Object::Pluggable::Pipeline> documentation. The methods 
described regarding pipeline manipulation are available via C<$core>.

=head3 Registering for events

Registering for events typically happens at plugin load-time; in other 
words, inside C<Cobalt_register>:

  my ($self, $core) = @_;
  
  $core->plugin_register( $self, 'SERVER',
    [ 'chan_sync' ],
    [ 'public_msg' ],
  );
  
  ## or to receive all events:
  $core->plugin_register( $self, 'SERVER',
    [ 'all' ],
  );


=head3 Event handlers

Syndicated SERVER events become prefixed with Bot_ when handed off to plugins:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    my $deref_first_arg = ${ $_[0] };
    ...
  }

B<IMPORTANT: the arguments passed to event handlers are ALWAYS references>

(Sometimes, they're references to references, such as a hashref.
If you don't know what that means, it's time to read L<perlreftut> and 
L<perlref> immediately.)

This means that it's intended behavior to be able to modify the event's 
arguments before it continues through the plugin pipeline.

Be aware of this behavior and code appropriately.

Don't be confused, yet! For the most part, you can just dereference args 
as shown in the example above.


=head3 Returning proper values

The plugin system is a pipeline.

Unless manipulated manually, Cobalt's pipeline starts with the core 
('Main' context) IRC plugin provided by L<Cobalt::IRC>, followed by 
any plugins specified in plugins.conf.

That being the case, events will be handed on down the pipeline, 
B<unless> a handler for a syndicated event returns an B<EAT_ALL> or 
B<EAT_PLUGIN> value.

Your Bot_* event handlers should B<always> return an 
L<Object::Pluggable::Constants> value. The two commonly used values are:

=head4 PLUGIN_EAT_NONE

Allow the event to continue to pass through the pipeline.

B<This is the most common return value for event handlers.>

=head4 PLUGIN_EAT_ALL 

Eat the event, removing it from the plugin pipeline.

Typically you might return *_EAT_ALL on self-syndicated events.

For example, a plugin that breaks up a loop into chunks without its 
own POE session might self-syndicate some kind of loop event, eating 
the event when the loop is complete (also see L</"ADVANCED CONCEPTS">).

This can also be useful when there is a good reason to terminate an 
event's lifetime; for example, implementing a plugin that loads itself 
at the front of the pipeline and restricts outgoing events based on 
some criteria.


=head2 Receiving IRC events

=head3 Understanding server context

IRC-driven events typically come with a server context attached, mapping 
the server's configured "name" to server state information and allowing a 
plugin to make sure responses get to the right place.

For example, when receiving a public message:

  sub Bot_public_msg {
    my ($self, $core) = splice @_, 0, 2;
    ## Get this message's server context
    ## Passed to most IRC events as the first argument:
    my $context = ${ $_[0] };
    
    ## ... later, when sending a response ...
    my $channel = $msg->{channel};
    $core->send_event( 'send_message',
      $context,    ## make sure it goes to the right server
      $channel,    ## destination channel on specified context
      $response,   ## some response string
    );
  }

See L<Cobalt::IRC> for a list of IRC events and their event syntax.


=head3 Messages

FIXME

=head3 Commands

A B<Cobalt> instance has a B<CmdChar>, usually defined in I<etc/cobalt.conf>.
When any user issues a command prefixed with the bot's CmdChar, the event 
B<public_cmd_$CMD> is issued in addition to the normal B<public_msg> event.

  <JoeUser> !shorten http://www.cobaltirc.org/dev/bots
  ## -> event 'Bot_public_cmd_shorten'

The command is automatically lowercased before being transformed into an event.

A plugin can register to receive commands in this format:

  ## in Cobalt_register, usually:
  $core->plugin_register( $self, 'SERVER',
    ## register to receive the 'shorten' command:
    [ 'public_cmd_shorten' ],
  );
  
  ## handler for same:
  sub Bot_public_cmd_shorten {
    my ($self, $core) = splice @_, 0, 2;
    my $context = ${ $_[0] };
    my $msg = ${ $_[1] };
    
    ## since this is a command, our message_array is shifted
    ## the command will be stripped
    my @args = @{ $msg->{message_array} };
    
    . . . 
    
    ## if this command is "ours" we might want to eat it:
    return PLUGIN_EAT_ALL
  }


It's important to note that B<<$msg->{message_array}>> is shifted leftwards 
in B<public_cmd_> handlers; it won't contain the CmdChar-prefixed command.

Additionally, a B<Bot_public_msg> will be broadcast as normal (with the 
B<<$msg->{cmdprefix}>> element set to boolean true).

=head3 Other events

All of the typical instances of "stuff going on" on IRC are 
reported by the core IRC module in context "Main"

B<
The documentation for all events parsed and re-broadcast from IRC 
is available via the Cobalt::IRC POD
>

See L<Cobalt::IRC>.

=head2 Sending IRC events

L<Cobalt::IRC> receives the following commonly-used events:

=head3 Sending messages

=head4 send_message

The B<send_message> event triggers an IRC PRIVMSG to either a channel 
or user.

The arguments specify the server context, target (user or channel), and 
string, respectively:

  $core->send_event( 'send_message',
    $context, $target, $string
  );

The message will be sent after being processed by any L</Outgoing_message> 
handlers in the pipeline.

=head4 send_notice

B<send_notice> operates essentially the same as L</send_message>, except 
a NOTICE is sent (rather than PRIVMSG).

Event arguments are the same.

=head3 Channel-related commands

=head4 join

FIXME

=head4 part

FIXME

=head4 kick

FIXME

=head4 mode

FIXME

=head4 topic

FIXME


=head3 Accessing the IRC component directly

The IRC backend for the core distribution is L<POE::Component::IRC>,
more specifically the C<State> subclass.

L<POE::Component::IRC> is a very mature and complete IRC framework.

If your plugin does any kind of IRC-related heavy lifting, you will 
almost certainly want to consult the documentation for 
L<POE::Component::IRC> and L<POE::Component::IRC::State>.


=head4 Obtaining the IRC component

You can retrieve the IRC component object for direct access via the 
core's get_irc_obj method. Expects a server context:

  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = ${$_[0]};
    my $irc = $core->get_irc_obj($context);
  }


=head4 Frequently useful PoCo::IRC commands

FIXME



=head2 Core methods

The Cobalt core provides various useful accessors and methods for plugins.

B<NOTE:> The object reference to the Cobalt core object is referred to here 
as C<$core>. How you keep track of $core is your business; storing it in 
$self is generally fairly convenient:

  ## often in our Cobalt_register method:
  $self->{core} = $core;
  ...
  ## later, in an internal method...
  my $plug_cf = $self->{core}->get_plugin_cfg(__PACKAGE__);


=head3 Accessors

=head4 Provided

FIXME

=head4 get_core_cfg

  my $core_cf = $core->get_core_cfg()

Retrieves the 'core' configuration directives from C<cobalt.conf>.

=head4 get_channels_cfg

  my $chan_cf = $core->get_channels_cfg( $context );

Retrieves per-context channel configuration from C<channels.conf>.

The server context must be specified. 'undef' will be returned if it is not.

Returns an empty hash if there is no channel configuration for this 
server context.

=head4 get_plugin_cfg

  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ ) || {};

Retrieves the configuration hash for a specific plugin.

The package name for the plugin must be specified.

Returns a hashref that is a copy of the plugin's config, as found 
in I<<$core->cfg->{plugin_cf}->{__PACKAGE__}>>

Returns boolean false if there is no plugin configuration stored in 
memory:

  $core->log->warn("Missing config for __PACKAGE__")
    unless $core->get_plugin_cfg( __PACKAGE__ );


=head4 get_irc_casemap

  my $casemapping = $core->get_irc_casemap( $context );

Retrieves the CASEMAPPING rules for the specified server context, 
which should be one of: I<rfc1459>, I<strict-rfc1459>, I<ascii>

The server's casemapping is (should be) declared in ISUPPORT (numeric 005) 
upon connect and can be used to establish whether or not the character sets 
{}|^ are equivalent to []\~ -- see L</"IRC CAVEATS"> below for more 
information.

This can be used to feed the C<lc_irc/uc_irc/eq_irc> functions from 
L<IRC::Utils> and determine issues like nickname equivalency:

  use IRC::Utils qw/lc_irc eq_irc/;
  my $casemapping = $core->get_irc_casemap( $context );
  my $irc_lower = lc_irc($nickname, $


=head4 get_irc_obj

  my $irc = $core->get_irc_obj( $context );

Retrieve the L<POE::Component::IRC> object for a specified context, which 
is likely to actually be a L<POE::Component::IRC::State> instance.

This can be used to query or post events to the IRC component directly.

See the L<POE::Component::IRC> and L<POE::Component::IRC::State> docs for 
more on interacting directly with the IRC component.


=head4 get_irc_server

  my $server_state = $core->get_irc_server( $context );

Retrieves the appropriate hash reference from B<$core->Servers>

A server context must be specified.

The referenced hash has the following keys:

=over

=item *

B<Object>: The POE::Component::IRC object, see L</get_irc_obj>

=item *

B<Connected>: Boolean true/false; flipped on connect/disconnect events

=item *

B<ConnectedAt>: Most recent irc_001 (welcome) event timestamp

=item *

B<Name>: What we think this server is called

=item *

B<CaseMap>: The server's announced CASEMAPPING (or 'rfc1459'); see L</"IRC CAVEATS">

=item *

B<MaxModes>: The server's announced MAXMODES (or 4)

=back


=head4 auth_level

Retrieves the user's authorized level (or '0' for unauthorized users).

Requires a context and a nickname:

  ## inside a msg or command handler, f.ex:
  my ($self, $core) = splice @_, 0, 2;
  my $context = ${ $_[0] };
  my $msg   = ${ $_[1] };
  my $nick  = $msg->{src_nick};
  my $level = $core->auth_level($context, $nick);

Auth levels are fairly flexible; it is generally a good idea for your 
plugin to provide some method of configuring required access levels.

FIXME link to info on plugin conf / PluginOpts

=head4 auth_username

Retrieves the "username" for an authorized user (or empty list if the user 
is not currently authorized).

Requires a context and a nickname, similar to L</auth_level>:

  my $username = $core->auth_username($context, $nick);
  unless ($username) {
    ## this user isn't authorized
  }

=head4 auth_flags

FIXME

=head4 auth_pkg

FIXME


=head3 Logging

The Cobalt core provides a B<log> method that writes to the LogFile 
specified in cobalt.conf (and possibly STDOUT, if running with --nodetach).

This is actually a L<Log::Handler> instance, so all methods found there 
apply. Typically, plugins should log to B<info>, B<warn>, or B<debug>:

  $core->log->info("An informational message");
  
  $core->log->warn("Some error occured");

  $core->log->debug("some verbose debug output for --debug");

A plugin should at least log to B<info> when it is registered or 
unregistered; that is to say, inside B<Cobalt_register> and 
B<Cobalt_unregister> handlers.

=head3 Timers

Core timers live in $core->TimerPool ; if need be, you can access 
the timer pool directly via $core->TimerPool->{TIMERS}, which is a 
hash keyed on timer ID.

Typically most plugins will only need the following functionality:

=head4 timer_set

Set up a new timer for an event or message.

  $core->timer_set( $delay, $ev_hash );
  $core->timer_set( $delay, $ev_hash, $id );

Returns the timer ID on success, boolean false on failure.

Expects at least a delay (in seconds) and a hashref specifying what to 
do when the delay has elapsed.

  ## New 60 second 'msg' timer with a random unique ID:
  ## Send $string to $channel on $context
  ## (A triggered 'msg' timer broadcasts a 'send_message' event)
  my $id = $core->timer_set( 60,
    {
      ## The type of timer; 'msg' or 'event':
      Type => 'msg',

      ## This is a 'msg' timer; we need to know what to send:
      Context => $context,
      Target  => $channel,
      Text    => $string,
    }
  );


If no B<Type> is specified, I<event> is assumed:

  ## Trigger event $event in $secs with (optional) @args:
  my $id = $core->timer_set( $secs,
    {
      Event => $event,
      Args  => [ @args ],
    }
  );


By default, a random timer ID is chosen (and returned).

You can also specify an ID:

  ## Set a timer with specified ID 'MyTimer'
  ## Will overwrite any preexisting timers with the same ID
  $core->timer_set( 
    $secs,
    { Event => $event, Args => [ @args ] },
    'MyTimer'
  );

This can be useful for resetting timers you've already set; grab the ID 
returned by a C<timer_set()> call and reset it to change the event or delay.

You may want C<timestr_to_secs> from L<Cobalt::Utils> for easy 
conversion of human-readable strings into seconds.

If you need better accuracy, you'll need to use your own alarm()/delay() 
calls to L<POE::Kernel>; the timer pool is checked every second or so.


=head4 timer_del

Delete a timer by ID.

  my $deleted = $core->timer_del( $id );

Returns the deleted TimerPool entry, or nothing if there was no such ID.

The returned result (if there is one) can be fed back to L</timer_set> 
if needed:

  ## hang on to this timer for now:
   my $postponed = $core->timer_del( $id ) ;
  ## . . . situation changes . . .
   if ( $core->timer_set( 60, $postponed, $id ) ) {
     ## readding postponed timer successful
   }


=head4 timer_del_pkg

Delete all core timers owned by __PACKAGE__ :

  $core->timer_del_pkg( __PACKAGE__ );

Typically used by plugins that may need to clean up their core timers 
upon unregistering.


=head2 Syndicated core events

FIXME

=head3 Plugin-related

FIXME

=head3 Langset-related

FIXME

=head3 Timer-related

FIXME

=head3 Auth module

FIXME



=head1 PLUGIN DESIGN TIPS

=head2 Useful tools

FIXME

=head3 Cobalt::Plugin::WWW

It's fairly common to want to make some kind of HTTP request from an 
IRC bot. Unfortunately, the most common Perl method of speaking HTTP is 
L<LWP::UserAgent> -- which will block the plugin pipeline until the 
request is complete.

L<Cobalt::Plugin::WWW>, if loaded, provides an easy method of forking 
HTTP requests and reading responses back asynchronously via the 
B<www_request> event:

  ## build a request object via HTTP::Request
  use HTTP::Request;
  ## a simple GET, see HTTP::Request docs for more info:
  my $request = HTTP::Request->new( 'GET', $url );
  ## push it to www_request with a response event:
  $core->send_event( 'www_request',
    $request,
    'myplugin_resp_recv',
     ## you can include a reference containing args
     ## (or a scalar, if you like)
     ##
     ## here's an example args arrayref telling our handler 
     ## where to send responses:
     [ $context, $channel, $nickname ],
  );
  
  ## handle a response when one is received:
  sub Bot_myplugin_resp_recv {
    my ($self, $core) = splice @_, 0, 2;
    ## if the request was successful, $_[0] is a ref to the 
    ## undecoded content from HTTP::Response
    my $content  = ${ $_[0] };
    ## $_[1] is the HTTP::Response object, see perldoc HTTP::Response
    my $response = ${ $_[1] };
    ## $_[2] is whatever argument ref was provided in www_request
    my $argref   = ${ $_[2] };
    ## in our example above, it was some contextual info:
    my ($context, $channel, $nickname) = @$argref;

    ## . . . do something with the response . . .
  
    ## eat this event, we're the only handler:
    return PLUGIN_EAT_ALL
  }

When a response is received, it will be pushed to the plugin pipeline 
as the specified SERVER event.

If the plugin is available, B<<$core->Provided->{www_request}>> will be 
boolean true; you can fall back to LWP with a short timeout, perhaps:

  ## build request like above:
  my $request = HTTP::Request->new( . . . );
  if ($core->Provided->{www_request}) {
    ## send www_request event like above  
  } else {
    ## no async available, use LWP
    my $ua = LWP::UserAgent->new(
      timeout => 5,
      max_redirect => 0,
    );
    my $response = $ua->request($request);
    ## now $response is a HTTP::Response object
    my $content = $response->content;
  }



=head3 Cobalt::Utils

FIXME brief primer on useful Cobalt::Utils funcs

=head3 IRC::Utils

FIXME brief primer on IRC::Utils funcs

=head2 Keeping track of $core

FIXME

=head2 Using Moose

FIXME


=head1 ADVANCED CONCEPTS

=head2 Breaking up lengthy loops

FIXME discussion of pushing self-events back to pipeline to loop

=head2 Custom per-plugin language sets

FIXME discussion of using load_langset to create a 'local' RPL hash

=head2 Spawning your own POE::Session

FIXME discussion of plugins that initiate their own sessions

FIXME registering for events from irc...?

=head2 Manipulating plugin pipeline order

FIXME

=head2 Using POE::Component::IRC plugins

FIXME


=head1 IRC CAVEATS

=head2 IRC casemapping rules

Determining whether or not nicknames and channels are equivalent on IRC 
is not as easy as it looks.

Per the RFC (L<http://tools.ietf.org/html/rfc1459#section-2.2>):

  the characters {}| are
  considered to be the lower case equivalents of the characters []\,
  respectively

This set ( {}| == []\ ) is called B<strict-rfc1459> and identified as such in 
a server's I<ISUPPORT CASEMAPPING=> directive.

More often, servers use the set commonly identified as B<rfc1459>:

  ## rfc1459 lower->upper case change: {}|^ == []\~
  $value =~ tr/a-z{}|^/A-Z[]\\~/;

Some servers may use normal ASCII case rules; they will typically announce 
B<ascii> in I<CASEMAPPING=>.

L<Cobalt::IRC> will attempt to determine and save a server's CASEMAPPING value 
at connect time. Some broken server configurations announce junk in 
I<CASEMAPPING> and their actual valid casemapping ruleset in I<CHARSET>; 
L<Cobalt::IRC> will fall back to I<CHARSET> if I<CHARSET> is a valid casemap 
but I<CASEMAPPING> is invalid. If all else fails, B<rfc1459> is used. The 
saved value can be used to feed C<eq_irc> and friends from L<IRC::Utils> and
determine nickname/channel equivalency.

See L</get_irc_casemap> and L<IRC::Utils>



=head2 Character encodings

FIXME


=head1 SEE ALSO

Plugin authors should at least read the L<Cobalt::IRC> POD, and 
probably L<Cobalt::Utils> as well.

B<The easiest way to browse documentation is our POD converted to DokuWiki, 
available online:>

L<http://www.cobaltirc.org/docs/wiki/doku.php?id=bots:cobalt:docs:>

FIXME Cobalt-related links

=head2 Relevant CPAN documentation

=over

=item *

L<IRC::Utils>

=item *

L<POE::Component::IRC>

=item *

L<POE::Component::IRC::State>

=item *

L<POE::Component::Syndicator>

=item *

L<Object::Pluggable>

=item *

L<Object::Pluggable::Pipeline>

=item *

L<Object::Pluggable::Constants>

=back


=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

http://www.cobaltirc.org


=cut
