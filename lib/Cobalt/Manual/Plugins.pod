=pod

=head1 NAME

Cobalt::Manual::Plugins - Cobalt2 plugin-writing fundamentals guide

=head1 VERSION

Last updated for cobalt B<2.00_40>

=head1 DESCRIPTION

This POD attempts to be a reasonably complete guide to writing useful 
B<Cobalt2> plugins.

Refer to L</SEE ALSO> for other relevant documentation.

B<Plugin authors should at least read the L<Cobalt::IRC> POD>


=head1 PLUGIN FUNDAMENTALS

=head2 A basic plugin outline

  package Cobalt::Plugin::User::MyPlugin;
  our $VERSION = '0.001';

  use strict;
  use warnings;

  ## Import lots of useful stuff:
  use Cobalt::Common;
  
  ## Minimalist object constructor:
  sub new { bless {}, shift }
  
  ## Called when we are loaded:
  sub Cobalt_register {
    ## Handlers receive $self and $core as first two args:
    ##  $self is "this object"
    ##  $core gives us access to core attributes and methods
    my ($self, $core) = splice @_, 0, 2;
    
    ## Register to only receive public msg events
    ## (We could also register for a list or 'all')
    $core->plugin_register( $self, 'SERVER',
      [ 'public_msg' ]
    );
    
    ## Log that we're here now:
    $core->log->info("Registered");

    ## We could save $core to $self->{core} to make life easier 
    ## on our internal methods, perhaps:
    $self->{core} = $core;
    
    ## ALWAYS return an Object::Pluggable::Constants value
    ## (Importing Cobalt::Common will also pull _NONE and _ALL in)
    ## See "Returning proper values" under "Handling events"
    ## 
    ## PLUGIN_EAT_NONE is the most common:
    return PLUGIN_EAT_NONE
  }
  
  ## Called when we are unloaded:
  sub Cobalt_unregister {
    my ($self, $core) = splice @_, 0, 2;

    . . . do some clean up, perhaps . . .
    
    $core->log->info("Unregistering; bye!");
    return PLUGIN_EAT_NONE
  }
  
  ## Syndicated events become prefixed with 'Bot_' when dispatched
  ## (when calling send_event, leave the prefix out)
  sub Bot_public_msg {
    my ($self, $core) = splice @_, 0, 2;
    my $context = ${ $_[0] };
    my $msghash = ${ $_[1] };

    . . . do something with message . . .

    return PLUGIN_EAT_NONE 
  }
  
  1;  ## perl modules must end in '1;'


=head2 Module paths and configuration

=head3 plugins.conf

Plugins specified in plugins.conf (located in our etc/) will be 
automatically loaded at runtime unless B<NoAutoLoad> is specified.

C<plugins.conf> is YAML in the following structure:

  ---
  MyPlugin:
    Module: Cobalt::Plugin::User::MyPlugin
    Config: plugins/mine/myplugin.conf
    ## Enable to skip runtime auto-loading:
    #NoAutoLoad: 1
    ## Optional:
    Opts:
      Level: 2

Configuration files specified in 'Config: ' are expected to be valid 
B<YAML1.0>. You can read all about YAML at L<http://www.yaml.org> -- 
for the most part, YAML is fairly self-explanatory.
See L<Cobalt::Manual::PluginConf> for more about YAML and plugin configs.

The config file will be loaded when the plugin is; the data structure 
loaded will be stored in the core B<cfg> attribute, keyed by the plugin's 
alias.

Simple plugins might only need one or two config options; in this case, 
you can specify a B<Opts:> directive. It should be a hash (or a list, 
in very odd cases).

If an Opts: directive is supplied, it will be loaded as well; see 
L</PluginOpts>.


=head3 Accessing plugin configuration

Typically, a plugin's configuration is loaded into memory and stored 
in the Core C<cfg> attribute.

The normal way to access a plugin's configuration structure is via the 
core method B<get_plugin_cfg>:

  ## Our $self object or our alias must be specified:
  my $plug_cf = $core->get_plugin_cfg( $self );
  unless ($plug_cf) {
    ## No configuration found for our plugin ...
  }

Note that B<get_plugin_cfg> returns a COPY of the plugin's 
configuration structure.

If the plugin needs to modify its own configuration hash for some 
reason, it needs to access B<< $core->cfg->{plugin_cf} >> directly. 
See L</"Directly accessing cfg hash">, below.

See also: L</"Core methods">

=head4 PluginOpts

A plugin with a fairly involved configuration set should have its own 
configuration file.

If the plugin only has a small number of configuration directives, it is 
possible to specify options in C<plugins.conf> directly via B<Opts>:

  ## plugins.conf:
  MyPlugin:
    Module: Cobalt::Plugin::User::MyPlugin
    Opts:
      Some_Option: value
      ## ..etc

Any B<Opts> specified in C<plugins.conf> directly will be available to the 
plugin via the B<PluginOpts> key:

  my $plug_cf  = $core->get_plugin_cfg( $self );
  my $some_opt = $plug_cf->{PluginOpts}->{Some_Option} // 

a B<Config:> directive can be specified as normal, although this is 
typically counterproductive; use either an external config file or a 
B<Opts:> directive to retain your users' sanity.

=head4 Examples

FIXME
FIXME examples of required levels hash, etc

=head4 Directly accessing cfg hash

If your plugin needs to modify its configuration values directly 
(which is often unwise!), it will need to access the B<< $core->cfg >> 
hash directly.

Loaded configuration values for plugins are available via 
B<< $core->cfg->{plugin_cf} >>, keyed on plugin alias:

  ## ask Core for our current alias:
  my $alias = $core->get_plugin_alias( $self );
  my $plug_cf = $core->cfg->{plugin_cf}->{ $alias };
  ## modify this plugin's conf hash directly:
  $plug_cf->{Opts}->{Some_Boolean_Opt} = 1;

There is no built-in facility for writing these changes back out as of 
this writing; plugins are on their own for configuration file modification.  


=head2 Handling events

Plugins are fundamentally event driven.

A plugin will (usually at load-time) register to receive some set of 
events, which are pushed through the pipeline by the Cobalt core (with 
help from L<POE::Component::Syndicator> and L<Object::Pluggable>).

If your plugin needs to have a certain priority in the pipeline, you're 
going to want to spend some quality time reading the L<Object::Pluggable> 
and especially L<Object::Pluggable::Pipeline> documentation. The methods 
described regarding pipeline manipulation are available via C<$core>.

=head3 Registering for events

Registering for events typically happens at plugin load-time; in other 
words, inside C<Cobalt_register>:

  my ($self, $core) = @_;
  
  $core->plugin_register( $self, 'SERVER',
    [ 'chan_sync' ],
    [ 'public_msg' ],
  );
  
  ## or to receive all events:
  $core->plugin_register( $self, 'SERVER',
    [ 'all' ],
  );


=head3 Event handlers

Syndicated SERVER events become prefixed with Bot_ when handed off to plugins:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    my $deref_first_arg = ${ $_[0] };
    ...
  }

B<IMPORTANT: the arguments passed to event handlers are ALWAYS references>

(Sometimes, they're references to references, such as a hashref.
If you don't know what that means, it's time to read L<perlreftut> and 
L<perlref> immediately.)

This means that it's intended behavior to be able to modify the event's 
arguments before it continues through the plugin pipeline.

Be aware of this behavior and code appropriately.

B<Don't be confused, yet!> For the most part, you can just dereference args 
as shown in the example above. The dereferenced value might be a simple 
scalar, or it might be a reference of some sort, such as a hash:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    ## handler that expects a hash(ref) as the first argument:
    my $ev_hash = ${ $_[0] };    

    unless (ref $ev_hash eq 'HASH') {
      ## didn't get the input we expected!
      $core->log->warn("some_event expected a hashref");
      return PLUGIN_EAT_NONE
    }
    
    my $item = $ev_hash->{some_item};
    . . .
    
    return PLUGIN_EAT_NONE
  }

B<Be cautious with your argument modifiers!>

For example, when splicing values from a C<< $msg->{message_array} >> 
(I<< L</Messages> >>):

  ## copy, then splice/shift/pop
  my @message = @{ $msg->{message_array} };
  my ($first, $second) = splice @message, 0, 2;
  my $third = shift @message;


=head3 Returning proper values

The plugin system is a pipeline.

Unless manipulated manually, Cobalt's pipeline starts with the core 
('Main' context) IRC plugin provided by L<Cobalt::IRC>, followed by 
any plugins specified in plugins.conf.

That being the case, events will be handed on down the pipeline, 
B<unless> a handler for a syndicated event returns an B<EAT_ALL> or 
B<EAT_PLUGIN> value.

Your Bot_* event handlers should B<always> return an 
L<Object::Pluggable::Constants> value. The two commonly used values are:

=head4 PLUGIN_EAT_NONE

Allow the event to continue to pass through the pipeline.

B<This is the most common return value for event handlers.>

=head4 PLUGIN_EAT_ALL 

Eat the event, removing it from the plugin pipeline.

Typically you might return PLUGIN_EAT_ALL on self-syndicated events
(that is to say, events the plugin intends for itself to handle, 
such as a L<Cobalt::Plugin::WWW> response, timed event, event-aware 
loop as described in L</"ADVANCED CONCEPTS">, etc.)

This can also be useful when there is a good reason to terminate an 
event's lifetime; for example, implementing a plugin that loads itself 
at the front of the pipeline and restricts outgoing events based on 
some criteria.

=head1 USING IRC

=head2 Receiving IRC events

=head3 Understanding server context

IRC-driven events typically come with a server context attached, mapping 
the server's configured "name" to server state information and allowing a 
plugin to make sure responses get to the right place.

For example, when receiving a public message:

  sub Bot_public_msg {
    my ($self, $core) = splice @_, 0, 2;
    ## Get this message's server context
    ## Passed to most IRC events as the first argument:
    my $context = ${ $_[0] };
    
    ## ... later, when sending a response ...
    my $channel = $msg->{channel};
    $core->send_event( 'send_message',
      $context,    ## make sure it goes to the right server
      $channel,    ## destination channel on specified context
      $response,   ## some response string
    );
  }

See L<Cobalt::IRC> for a list of IRC events and their event syntax.


=head3 Messages

The most common use-case for an IRC bot is, of course, responding to 
messages.

Incoming messages are handled by B<Bot_public_msg> and B<Bot_private_msg> 
plugin event handlers. (If they are prefixed by our CmdChar, they'll 
I<also> trigger a Bot_public_cmd_ event -- see L</"Commands">, below).

A _msg event is passed a context and a C<$msg> hash:

  sub Bot_public_msg {
    my ($self, $core) = splice @_, 0, 2;
    my $context = ${ $_[0] };
    my $msg     = ${ $_[1] };
    
    ## You probably don't want to eat IRC events, unless 
    ## you're quite sure of what you're doing:
    return PLUGIN_EAT_NONE
  }

The C<$msg> hash has the following keys:

=over

=item *

B<myself> => bot's current nickname

=item *

B<src> => full nick!user@host of the message source

=item *

B<src_nick>, B<src_user>, B<src_host>

=item *

B<channel>, B<target> => channel or nick of first target seen

=item *

B<target_array> => array of targets message was seen on

=item *

B<orig> => original, unparsed message content

=item *

B<message> => format/color-stripped message content

=item *

B<highlight> => true if the bot was being addressed

=item *

B<cmdprefix> => true if the string was CmdChar-prefixed

=item *

B<cmd> => the relevant command if B<cmdprefix> is true

=back

B<Note that a '/ME' is a CTCP ACTION and not handled by _msg handlers.>
For that, you'll need to catch B<Bot_ctcp_action>, which carries 
essentially the same syntax. (If the action is sent to a channel, the 
key 'channel' will be available in the message's hash.)

Additionally, a '/NOTICE' is not a _msg. B<Bot_notice> also carries the 
same syntax.

B<< See L<Cobalt::IRC> for more details. >>

=head3 Commands

A B<Cobalt> instance has a B<CmdChar>, usually defined in I<etc/cobalt.conf>.
When any user issues a command prefixed with the bot's CmdChar, the event 
B<public_cmd_$CMD> is issued in addition to the normal B<public_msg> event.

  <JoeUser> !shorten http://www.cobaltirc.org/dev/bots
  ## -> event 'Bot_public_cmd_shorten'

The command is automatically lowercased before being transformed into an event.

A plugin can register to receive commands in this format:

  ## in Cobalt_register, usually:
  $core->plugin_register( $self, 'SERVER',
    ## register to receive the 'shorten' command:
    [ 'public_cmd_shorten' ],
  );
  
  ## handler for same:
  sub Bot_public_cmd_shorten {
    my ($self, $core) = splice @_, 0, 2;
    my $context = ${ $_[0] };
    my $msg = ${ $_[1] };
    
    ## since this is a command, our message_array is shifted
    ## the command will be stripped
    my @args = @{ $msg->{message_array} };
    
    . . . 
    
    ## if this command is "ours" we might want to eat it:
    return PLUGIN_EAT_ALL
  }


It's important to note that B<< $msg->{message_array} >> is shifted leftwards 
in B<public_cmd_> handlers; it won't contain the CmdChar-prefixed command.

Additionally, a B<Bot_public_msg> will be broadcast as normal (with the 
B<< $msg->{cmdprefix} >> element set to boolean true).

=head3 Other events

All of the typical instances of "stuff going on" on IRC are 
reported by the core IRC module in context "Main"

B<
The documentation for all events parsed and re-broadcast from IRC 
is available via the Cobalt::IRC POD
>

See L<Cobalt::IRC>.

=head2 Sending IRC events

L<Cobalt::IRC> receives the following commonly-used events:

=head3 Sending messages

=head4 send_message

The B<send_message> event triggers an IRC PRIVMSG to either a channel 
or user.

The arguments specify the server context, target (user or channel), and 
string, respectively:

  $core->send_event( 'send_message',
    $context, $target, $string
  );

The message will be sent after being processed by any B<Outgoing_message> 
handlers in the pipeline. See L<Cobalt::IRC> for more about Outgoing_* 
handlers.

=head4 send_notice

B<send_notice> operates essentially the same as L</send_message>, except 
a NOTICE is sent (rather than PRIVMSG).

Event arguments are the same.

=head4 send_action

B<send_action> sends a CTCP ACTION rather than a normal PRIVMSG or 
NOTICE string.

Event arguments are the same as L</send_message> and L</send_notice>.


=head3 Channel-related commands

The following common IRC commands are handled.

Like any other interaction, they are sent as events:

  ## (attempt to) join a channel on $context:
  $core->send_event( 'join', $context, $channel );

=over

=item *

B<join>

=item *

B<part>

=item *

B<mode>

=item *

B<kick>

=item *

B<topic>

=back

See L<Cobalt::IRC> for event argument syntax and details.


=head3 Accessing the IRC component directly

The IRC backend for the core distribution is L<POE::Component::IRC>,
more specifically the C<State> subclass.

L<POE::Component::IRC> is a very mature and complete IRC framework.

If your plugin does any kind of IRC-related heavy lifting, you will 
almost certainly want to consult the documentation for 
L<POE::Component::IRC> and L<POE::Component::IRC::State>.


=head4 Obtaining the IRC component

You can retrieve the IRC component object for direct access via the 
core's get_irc_obj method. Expects a server context:

  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = ${$_[0]};
    my $irc = $core->get_irc_obj($context);
  }

See L<POE::Component::IRC> and L<POE::Component::IRC::State> for details 
on the methods you can call against C<$irc> -- they are very complete.


=head1 USING THE CORE

=head2 Core methods

The Cobalt core provides various useful accessors and methods for plugins.

B<NOTE:> The object reference to the Cobalt core object is referred to here 
as C<$core>. How you keep track of $core is your business; see 
L</"Keeping track of $core">


=head3 Attributes

=head4 Provided

The B<Provided> hash allows plugins to declare that some functionality 
or event provided by the plugin is available (for example, the 
B<< $core->Provided->{www_request} >> element is boolean true if 
L<Cobalt::Plugin::WWW> is registered).

This is useful when your plugin provides some event interface usable 
by other plugins, or when the presence of this plugin may alter 
another plugin's behavior.

A plugin should declare its Provided functionality at register-time:

  sub Cobalt_register {
    my ($self, $core) = splice @_, 0, 2;
    
    ## ... register for events, etc ...

    ## declare that 'tasty_snacks' functionality is available
    ## this example does nothing if it's already defined (//):
    $core->Provided->{tasty_snacks} //= 1;
    
    return PLUGIN_EAT_NONE
  }

B<The core has no way of automatically knowing that this functionality 
disappears when your plugin does.>

You should delete the Provided element in your _unregister:

  sub Cobalt_unregister {
    my ($self, $core) = splice @_, 0, 2;
    
    delete $core->Provided->{tasty_snacks};
    
    $core->log->info("Bye!");
    return PLUGIN_EAT_NONE
  }

Some plugins use this to share simple bits of state information in 
addition to their advisory nature; for example, L<Cobalt::Plugin::RDB> 
shares the number of items in the 'main' RDB via the integer value of 
B<< $core->Provided->{randstuff_items} >>.

Therefore, when attempting to determine whether a specific piece of 
functionality is available, it may be advisable to check for 'defined' 
status instead of boolean value:

  if ( defined $core->Provided->{randstuff_items} ) {
    ## we have RDB.pm
  }

(More complicated data-sharing should be done via event interfaces or 
I<if absolutely necessary> via a data structure in L</State>; see below.)

Since plugin load order is generally not guaranteed and plugins may 
be dynamically (un)loaded, it is good practice to only check for 
B<Provided> functionality in the narrowest possible scope; that is to 
say, directly prior to execution of the dependent code, rather than at 
plugin register-time.

=head4 State

The B<< $core->State >> hashref is the global state hash.

B<Unless you're quite sure of what you're doing, you probably do not 
want to play with the top-level State hash.>

However, if you absolutely I<must> synchronously share some data 
between a set of plugins, B<< $core->State->{HEAP} >> is initialized 
as a hashref and guaranteed to be untouched by the core plugin set.
(Of course, that doesn't mean 3rd party plugins can't overwrite each 
other; use a uniquely-named deeper data structure within {HEAP}.)

State should be treated cautiously; you can easily break the 
current instance by clobbering values. Most important bits available 
in the top-level hash can be pulled out via methods described herein.

=head4 Servers

B<< $core->Servers >> is a hashref keyed on server "context" name; see 
L</"Understanding server context">.

B<You should probably be using L</get_irc_server>!>

The only valid reason to access ->Servers directly is to iterate all 
contexts:

  my $servers = $core->Servers;
  for my $context ( keys %$servers ) {
    . . .
  }

=head4 var

Returns the path to the current VAR dir, typically used for log files, 
databases, or other potentially dynamic data.

Plugins should typically dump serialized data and place databases in a 
path under B<< $core->var >> -- to avoid clobbering files, non-trivial 
plugins using databases or serialization are encouraged to create their 
own directories under B<< $core->var >> for storage.

=head4 version

Returns the current Cobalt::Core version.

This can be used to require a specific Cobalt version for a 3rd-party 
plugin (via die()/croak() in Cobalt_register).

=head4 detached

Returns a boolean value indicating whether or not this Cobalt instance 
is attached to a terminal or daemonized.


=head3 Configuration-related methods

=head4 get_core_cfg

  my $core_cf = $core->get_core_cfg()

Retrieves the 'core' configuration directives from C<cobalt.conf>.

This includes configuration for L<Cobalt::IRC>:

  my $core_cf = $core->get_core_cfg();
  my $cf_serverport = $core_cf->{IRC}->{ServerPort};

=head4 get_channels_cfg

  my $chan_cf = $core->get_channels_cfg( $context );

Retrieves per-context channel configuration from C<channels.conf>.

The server context must be specified. 'undef' will be returned if it is not.

Returns an empty hash if there is no channel configuration for this 
server context.

=head4 get_plugin_cfg

  my $plug_cf = $core->get_plugin_cfg( $self ) || {};

Retrieves the configuration hash for a specific plugin.

Either the plugin's C<$self> object or its current alias must be 
specified.

Returns a hashref that is a copy of the plugin's config, as found 
in I<< $core->cfg->{plugin_cf}->{$alias} >>

Returns undef if there is no plugin configuration stored for this 
plugin:

  $core->log->warn("Missing config!")
    unless $core->get_plugin_cfg( $self );

=head4 get_plugin_alias

As of 2.00_19 a plugin can be instanced many times with discrete conf 
values. Sometimes it's useful to know the name of your current alias.

Your plugin's $self object must be specified:

  my $plugin_alias = $core->get_plugin_alias( $self );

(Of course, this also works for getting the alias of other plugin 
objects.)

=head3 IRC-related methods

=head4 get_irc_casemap

  my $casemapping = $core->get_irc_casemap( $context );

Retrieves the CASEMAPPING rules for the specified server context, 
which should be one of: I<rfc1459>, I<strict-rfc1459>, I<ascii>

The server's casemapping is (should be) declared in ISUPPORT (numeric 005) 
upon connect and can be used to establish whether or not the character sets 
{}|^ are equivalent to []\~ -- see L</"IRC CAVEATS"> below for more 
information.

This can be used to feed the C<lc_irc/uc_irc/eq_irc> functions from 
L<IRC::Utils> and determine issues like nickname equivalency:

  use IRC::Utils qw/lc_irc eq_irc/;
  my $casemapping = $core->get_irc_casemap( $context );
  my $irc_lower = lc_irc($nickname, $


=head4 get_irc_obj

  my $irc = $core->get_irc_obj( $context );

Retrieve the L<POE::Component::IRC> object for a specified context, which 
is likely to actually be a L<POE::Component::IRC::State> instance.

This can be used to query or post events to the IRC component directly.

See the L<POE::Component::IRC> and L<POE::Component::IRC::State> docs for 
more on interacting directly with the IRC component.


=head4 get_irc_server

  my $server_state = $core->get_irc_server( $context );

Can also be called via B<get_irc_context>.

Retrieves the appropriate hash reference from B<< $core->Servers >>

A server context must be specified.

The referenced hash has the following keys:

=over

=item *

B<Object>: The POE::Component::IRC object, see L</get_irc_obj>

=item *

B<Connected>: Boolean true/false; flipped on connect/disconnect events

=item *

B<ConnectedAt>: Most recent irc_001 (welcome) event timestamp

=item *

B<Name>: What we think this server is called

=item *

B<CaseMap>: The server's announced CASEMAPPING (or 'rfc1459'); see L</"IRC CAVEATS">

=item *

B<MaxModes>: The server's announced MAXMODES (or 4)

=back


=head3 Auth-related methods

=head4 auth_level

Retrieves the user's authorized level (or '0' for unauthorized users).

Requires a context and a nickname:

  ## inside a msg or command handler, f.ex:
  my ($self, $core) = splice @_, 0, 2;
  my $context = ${ $_[0] };
  my $msg   = ${ $_[1] };
  my $nick  = $msg->{src_nick};
  my $level = $core->auth_level($context, $nick);

Auth levels are fairly flexible; it is generally a good idea for your 
plugin to provide some method of configuring required access levels.

FIXME link to info on plugin conf / PluginOpts

=head4 auth_username

Retrieves the "username" for an authorized user (or empty list if the user 
is not currently authorized).

Requires a context and a nickname, similar to L</auth_level>:

  my $username = $core->auth_username($context, $nick);
  unless ($username) {
    ## this user isn't authorized
  }

=head4 auth_flags

FIXME

=head4 auth_pkg

FIXME


=head3 Logging

The Cobalt core provides a B<log> method that writes to the LogFile 
specified in cobalt.conf (and possibly STDOUT, if running with --nodetach).

This is actually a L<Log::Handler> instance, so all methods found there 
apply. Typically, plugins should log to B<info>, B<warn>, or B<debug>:

  $core->log->info("An informational message");
  
  $core->log->warn("Some error occured");

  $core->log->debug("some verbose debug output for --debug");

A plugin should at least log to B<info> when it is registered or 
unregistered; that is to say, inside B<Cobalt_register> and 
B<Cobalt_unregister> handlers.

=head3 Timers

Core timers live in B<< $core->TimerPool >>; if need be, you can access 
the timer pool directly. It is a hash keyed on timer ID.

Typically most plugins will only need the following functionality:

=head4 timer_set

Set up a new timer for an event or message.

  $core->timer_set( $delay, $ev_hash );
  $core->timer_set( $delay, $ev_hash, $id );

Returns the timer ID on success, boolean false on failure.

Expects at least a delay (in seconds) and a hashref specifying what to 
do when the delay has elapsed.

  ## New 60 second 'msg' timer with a random unique ID:
  ## Send $string to $channel on $context
  ## (A triggered 'msg' timer broadcasts a 'send_message' event)
  my $id = $core->timer_set( 60,
    {
      ## The type of timer; 'msg', 'action' or 'event':
      Type => 'msg',

      ## This is a 'msg' timer; we need to know what to send
      ## 'action' carries the same syntax
      Context => $context,
      Target  => $channel,
      Text    => $string,
    }
  );


If no B<Type> is specified, I<event> is assumed:

  ## Trigger event $event in $secs with (optional) @args:
  my $id = $core->timer_set( $secs,
    {
      Event => $event,
      Args  => [ @args ],
    }
  );

You can tags packages with your plugin's B<Alias>, if you'd like; 
if an Alias is set, you'll be able to clear all timers by alias via 
L</timer_del_alias>:

  ## Alias-tagged timer
  my $id = $core->timer_set( $secs,
    {
      Event => $event,
      Args  => [ @args ],
      ## Safely retrieve our $self object's plugin alias:
      Alias => $core->get_plugin_alias( $self ),
    },
  );

Additionally, L<Cobalt::Plugin::PluginMgr> automatically tries to clear 
plugin timers for unloaded plugins; this only works for Alias-tagged timers.
Without a specified Alias, a timer is essentially considered ownerless -- 
it will happily fire at their scheduled time even if the issuing plugin 
is gone.

By default, a random timer ID is chosen (and returned).

You can also specify an ID:

  ## Set a timer with specified ID 'MyTimer'
  ## Will overwrite any preexisting timers with the same ID
  $core->timer_set( 
    $secs,
    { Event => $event, Args => [ @args ] },
    'MyTimer'
  );

This can be useful for resetting timers you've already set; grab the ID 
returned by a C<timer_set()> call and reset it to change the event or delay.

You may want C<timestr_to_secs> from L<Cobalt::Utils> for easy 
conversion of human-readable strings into seconds. This is, of course, 
included by default if you C<< use L<Cobalt::Common> >>.

If you need better accuracy, you'll need to use your own alarm()/delay() 
calls to L<POE::Kernel>; the timer pool is checked every second or so.

Arguments specified in the B<Args> array reference will be relayed to 
plugin event handlers just like any other event:

  sub Bot_some_timed_event {
    ## Called by a timer_set() timer
    my ($self, $core) = splice @_, 0, 2;
    my $firstarg = ${ $_[0] };
    my $second   = ${ $_[1] };
  }


=head4 timer_del

Delete a timer by ID.

  my $deleted = $core->timer_del( $id );

Returns the deleted TimerPool entry, or nothing if there was no such ID.

The returned result (if there is one) can be fed back to L</timer_set> 
if needed:

  ## hang on to this timer for now:
   my $postponed = $core->timer_del( $id ) ;
  ## . . . situation changes . . .
   if ( $core->timer_set( 60, $postponed, $id ) ) {
     ## readding postponed timer successful
   }

=head4 timer_del_alias

Delete all timers owned by the specified alias:

  my $plugin_alias  = $core->plugin_get_alias( $self );
  my $deleted_count = $core->timer_del_alias( $plugin_alias );

Only works for timers tagged with their Alias; see L</timer_set>.
Timers with no Alias tag are considered essentially "ownerless" and left 
to their own devices; they'll fail quietly if the timed event was handled 
by an unloaded plugin.

This is also called automatically by the core plugin manager 
(L<Cobalt::Plugin::PluginMgr>) when a plugin is unloaded.

=head4 timer_get_alias

Find out which active timerIDs are owned by the specified alias:

  my $plugin_alias  = $core->plugin_get_alias( $self );
  my @active_timers = $core->timer_get_alias( $plugin_alias );

=head4 timer_get

Retrieve the hash for this active timer (or undef if not found).

  my $this_timer = $core->timer_get($id);


=head2 Syndicated core events

These are events sent by Cobalt::Core when various core states change.

You should probably return PLUGIN_EAT_NONE on all of these, unless 
you're absolutely sure of what you're doing.

=head3 Plugin related events

=head4 Bot_plugins_initialized

Broadcast when the initial plugin load has completed at start-time.

Carries no arguments.

=head4 Bot_plugin_error

FIXME

=head3 Langset related events

FIXME

=head3 Timer related events

=head4 Bot_executed_timer

Broadcast whenever a timer ID has been executed.

The first argument is the timer ID.

The second argument is the "tick" that the timer was executed from; this 
is an integer increased by one every time the core timer pool is 
checked; batched timer runs (set for exactly the same time) will execute 
within the same "tick."

=head4 Bot_deleted_timer

Broadcast whenever a timer ID has been deleted.

The first argument is the timer ID.

The second argument is a cloned copy of the original timer hash.

=head3 Ignore list related events

FIXME

=head1 PLUGIN DESIGN TIPS

=head2 Useful tools


=head3 Cobalt::Common

L<Cobalt::Common> is a simple exporter that will pull in common constants 
and utilities from L<Object::Pluggable::Constants>, L<IRC::Utils>, and 
L<Cobalt::Utils>.

Additionally, C<use Cobalt::Constant> will enable the B<strict> and 
B<warnings> pragmas.

This is provided as a convenience for plugin authors; rather than importing 
from a goodly handful of modules, you can simply:

  use Cobalt::Common;

Declaring strict and warnings explicitly are still good practice.

See L<Cobalt::Common> for details.

=head3 Cobalt::DB

L<Cobalt::DB> provides an easy object-oriented interface to storing 
and retrieving Perl data structures to/from BerkeleyDB via L<DB_File>.

This is useful when a plugin has some persistent data it needs to 
keep track of, but storing it in memory and serializing to/from disk is 
too expensive.

  use Cobalt::DB;
   # new object for this db, creating it if it doesn't exist:
  $db = Cobalt::DB->new(
    File => $some_db_path,
  );
   # open and lock the db
   # be sure to error-check dbopen somehow:
  $db->dbopen || return "database open failed!";
   # 'put' some data structure in the db:
  my $ref = { Some => [ 'Data', 'Structure' ] };
  $db->put('MyKey', $ref);
   # 'get' some other data structure:
  my $other_data = $db->get('OtherKey');
   # close/unlock db:
  $db->dbclose;

See L<Cobalt::DB> for complete usage information.

=head3 Cobalt::Serializer

It is often useful to serialize arbitrary data structures to some 
standardized format. Serialization formats such as B<JSON> and B<YAML> 
are convenient for "speaking" to other networked applications, sharing 
data, or saving persistent data to disk in an easily-retrievable format.

B<Cobalt> comes with a simple object oriented frontend to some common 
serialization formats, as well as built-in file operations for "freezing" 
and "thawing" data to/from files on disk:

  use Cobalt::Serializer;
  ## create a JSON serializer:
  my $jsify = Cobalt::Serializer->new( Format => 'JSON' );
  ## serialize a perl hash:
  my $ref = { Some => { Deep => [ 'Structure' ] } };
  my $json = $jsify->freeze($ref);

See L<Cobalt::Serializer>.


=head3 Cobalt::Utils

L<Cobalt::Utils> provides a functional-style interface to various tools 
useful in effective plugin authoring.

Tools include flexible (bcrypt-enabled) password hashing and comparison 
functions, string formatting with arbitrary variable replacement rules, 
Cobalt-style glob syntax tools, color/format interpolation, and others.

  ## Import all Cobalt::Utils funcs:
  use Cobalt::Utils qw/ :ALL /;

See L<Cobalt::Utils>


=head3 IRC::Utils

L<IRC::Utils> is a great little module covering many basic IRC-related 
tasks, such as host normalization and matching and casemapping-aware 
uppercase/lowercase tools.

It is used extensively by both B<Cobalt> and L<POE::Component::IRC>; 
in other words, it is guaranteed to be available if B<Cobalt> is.

See L<IRC::Utils> for upstream documentation.


=head3 Cobalt::Plugin::WWW

It's fairly common to want to make some kind of HTTP request from an 
IRC bot. Unfortunately, the most common Perl method of speaking HTTP is 
L<LWP::UserAgent> -- which will block the plugin pipeline until the 
request is complete.

L<Cobalt::Plugin::WWW>, if loaded, provides an easy method of forking 
HTTP requests and reading responses back asynchronously via the 
B<www_request> event:

  ## build a request object via HTTP::Request
  use HTTP::Request;
  ## a simple GET, see HTTP::Request docs for more info:
  my $request = HTTP::Request->new( 'GET', $url );
  ## push it to www_request with a response event:
  $core->send_event( 'www_request',
    $request,
    'myplugin_resp_recv',
     ## you can include a reference containing args
     ## (or a scalar, if you like)
     ##
     ## here's an example args arrayref telling our handler 
     ## where to send responses:
     [ $context, $channel, $nickname ],
  );
  
  ## handle a response when one is received:
  sub Bot_myplugin_resp_recv {
    my ($self, $core) = splice @_, 0, 2;
    ## if the request was successful, $_[0] is a ref to the 
    ## undecoded content from HTTP::Response
    my $content  = ${ $_[0] };
    ## $_[1] is the HTTP::Response object, see perldoc HTTP::Response
    my $response = ${ $_[1] };
    ## $_[2] is whatever argument ref was provided in www_request
    my $argref   = ${ $_[2] };
    ## in our example above, it was some contextual info:
    my ($context, $channel, $nickname) = @$argref;

    ## . . . do something with the response . . .
  
    ## eat this event, we're the only handler:
    return PLUGIN_EAT_ALL
  }

When a response is received, it will be pushed to the plugin pipeline 
as the specified SERVER event.

If the plugin is available, B<< $core->Provided->{www_request} >> will be 
boolean true; you can fall back to LWP with a short timeout, perhaps:

  ## build request like above:
  my $request = HTTP::Request->new( . . . );
  if ($core->Provided->{www_request}) {
    ## send www_request event like above  
  } else {
    ## no async available, use LWP
    my $ua = LWP::UserAgent->new(
      timeout => 5,
      max_redirect => 0,
    );
    my $response = $ua->request($request);
    ## now $response is a HTTP::Response object
    my $content = $response->content;
  }


=head2 Keeping track of $core

It's frequently useful to maintain a reference to the Cobalt::Core 
object within your plugin, so that discrete methods can easily refer 
to core attributes and methods outside of an event handler.

The easiest way is to grab $core from Cobalt_register and store it 
somewhere in $self:
  
  sub Cobalt_register {
    ## get self and Cobalt::Core objects:
    my ($self, $core) = splice @_, 0, 2;
    
    ## stash $core in $self to make it available to internals:
    $self->{core} = $core;
    
    # ... do normal plugin registration ...
  }

  sub _my_method {
    my ($self) = @_;
    
    ## get $core back for ease of use:
    my $core = $self->{core};
  }

You could, of course, write a simple accessor:

  sub core {
    my ($self, $core) = @_;
    return $self->{CORE} = $core if $core and ref $core;
    return $self->{CORE}
  }
  
  ## in Cobalt_register:
  my ($self, $core) = splice @_, 0, 2;
  $self->core( $core );
  
  ## later, when you need it:
  $self->core->send_event( ... );


=head2 Non-reloadable plugins

By default, a plugin can be unloaded/reloaded at any time, typically via 
the L<Cobalt::Plugin::PluginMgr> !plugin administrative interface.

If a plugin is marked as being unreloadable, plugin managers such as the 
included L<Cobalt::Plugin::PluginMgr> will recognize it as such and 
refuse to unload or reload the plugin once it is loaded.

=head3 Declaring non-reloadable status

To declare itself as not being reloadable, a plugin simply needs to 
return a boolean true value in $self->{NON_RELOADABLE} at construction 
time:

  ## Plugin managers (should) refuse to reload this plugin.
  sub new { bless { NON_RELOADABLE => 1 }, shift }

Alternately, a method named NON_RELOADABLE will do:

  ## Like above but outside your constructor.
  ## Must return a boolean true value.
  sub NON_RELOADABLE { 1 }


=head3 Plugin managers and is_reloadable

All plugin load/unload frontends should make use of the Cobalt::Core 
method B<is_reloadable>.

Before unloading a plugin, a plugin manager should check the reloadable 
status of the plugin's alias:

  ## In a plugin manager of some sort, perhaps:
  unless ( $core->is_reloadable($plugin_alias) ) {
    ## plugin is not safe to reload on-the-fly
    # ... refuse to reload the plugin, log it ...
  }

When loading a plugin, a plugin manager should tell is_reloadable 
about the new object:

  my $plug_obj = My::Plugin->new;
   # ... add plugin to pipeline ...
  if ( $core->is_reloadable($plugin_alias, $plug_obj) ) {
    ## plugin is reloadable
  } else {
    ## plugin is NOT reloadable
    ## internal state has been updated to note same
  }


=head2 Using Moo

Cobalt::Core makes use of L<Moo> -- it's perfectly valid to use 
Moo for your plugins, as well:

  package Cobalt::Plugin::User::MyPlugin;
  
  ## Cobalt::Common will import types:
  use Cobalt::Common;
  
  use Moo;
  
  has 'core' => ( is => 'rw', isa => Object );
  
  sub Cobalt_register {
    my ($self, $core) = splice @_, 0, 2;
    $self->core( $core );
    # ...
    
    return PLUGIN_EAT_NONE
  }
  
L<Moo> is a lightweight class builder for Perl with 
largely Moose-compatible syntax. It can significantly simplify your 
plugins.

See L<MooX::Types::MooseLike::Base> for details on imported types.


=head1 ADVANCED CONCEPTS

=head2 Breaking up lengthy loops

Cobalt operates in an event loop -- implying that any piece of 
code that blocks for any significant length of time is holding up 
the rest of the loop:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    
    my @items = long_list_of_items();
    
    BIGLOOP: for my $item (@items) {
      do_work_on($item);
    }
    ## everything else stops until BIGLOOP is done
  }

Instead, you can break the loop into event handlers and yield back to 
the event loop, cooperatively multitasking with other events.

The below example processes a large list of items, pushing remaining 
items back to the 'worker' event handler after iterating 100 items.

  sub Cobalt_register {
    ## ... initialization...
    ## ... register for myplugin_start_work, myplugin_do_work
  }

  ## Some event that starts a long-running loop:
  sub Bot_myplugin_start_work {
    my ($self, $core) = splice @_, 0, 2;
    
    my @items = long_list_of_items();
        
     ## begin _do_work
     ## pass our @items to it, for example:
    $core->send_event( 'myplugin_do_work', [ @items ] );
    
    return PLUGIN_EAT_ALL   
  }
  
  sub Bot_myplugin_do_work {
    my ($self, $core) = splice @_, 0, 2;
    
     ## our remaining items:
    my $itemref = ${ $_[0] };
    my @items = @$itemref;
    
     ## maximum number of elements to process before yield:
    my $max_per_run = 100;
 
     ## work until there's no items left or we hit the max:
    my $counter = 0;
    while (@items && ++$counter < $max_per_run) {
      my $item = shift @items;
      ## ... do some work on $item ...
    }

     ## if there's any items left, push them and yield:
    if (@items) {
      $core->send_event( 'myplugin_do_work', [ @items ] );
    } else {
      ## no items left, we are finished
      ## tell pipeline we're done, perhaps:
      $core->send_event( 'myplugin_finished_work' );
    }

    return PLUGIN_EAT_ALL
  }

For more fine-grained control, consider running your own POE::Session; 
see L</"Spawning your own POE::Session">, below.


=head2 Custom per-plugin language sets

FIXME discussion of using load_langset to create a 'local' RPL hash

=head3 rplprintf

FIXME

=head2 Spawning your own POE::Session

There's nothing preventing you from spawning your own L<POE::Session>; 
your session will run within Cobalt's L<POE::Kernel> instance and POE 
event handlers will work as-normal.

Motivations for doing so include fine-grained timer control, integration 
with POE bits such as the POE::Component and POE::Wheel namespaces
. . . and the fact that POE is pretty great ;-)

See L<Cobalt::Plugin::WWW> source for an example of a plugin that uses 
its own POE::Session and L<POE::Wheel::Run> to manage forked workers 
asynchronously.


=head2 Manipulating plugin pipeline order

L<Object::Pluggable> allows you to manipulate the plugin pipeline order; 
that is to say, the order in which events will hit plugins.

For example, when writing a plugin such as an input filter, it can be useful to move 
your plugin towards the top of the plugin pipeline

FIXME examples


See L<Object::Pluggable::Pipeline> for details.

Plugin managers are not required to take any special consideration of a 
plugin's previous position in the case of a plugin (re)load.

=head1 IRC CAVEATS

=head2 IRC casemapping rules

Determining whether or not nicknames and channels are equivalent on IRC 
is not as easy as it looks.

Per the RFC (L<http://tools.ietf.org/html/rfc1459#section-2.2>):

  the characters {}| are
  considered to be the lower case equivalents of the characters []\,
  respectively

This set ( {}| == []\ ) is called B<strict-rfc1459> and identified as such in 
a server's I<ISUPPORT CASEMAPPING=> directive.

More often, servers use the set commonly identified as B<rfc1459>:

  ## rfc1459 lower->upper case change: {}|^ == []\~
  $value =~ tr/a-z{}|^/A-Z[]\\~/;

Some servers may use normal ASCII case rules; they will typically announce 
B<ascii> in I<CASEMAPPING=>.

L<Cobalt::IRC> will attempt to determine and save a server's CASEMAPPING value 
at connect time. Some broken server configurations announce junk in 
I<CASEMAPPING> and their actual valid casemapping ruleset in I<CHARSET>; 
L<Cobalt::IRC> will fall back to I<CHARSET> if I<CHARSET> is a valid casemap 
but I<CASEMAPPING> is invalid. If all else fails, B<rfc1459> is used.

(Relatedly, feel free to make fun of ParadoxIRC until they fix their daemons.)

The saved value can be used to feed C<eq_irc> and friends from L<IRC::Utils> and
determine nickname/channel equivalency.

See L</get_irc_casemap> and L<IRC::Utils>


=head2 Character encodings

IRC doesn't come with a lot of guarantees regarding character encodings.

Hopefully, you're getting either CP1252 or UTF-8.

The L<IRC::Utils> POD contains an excellent discussion of the general 
problem; see L<IRC::Utils/ENCODING>. Seriously. You really ought to read 
it carefully.

L<IRC::Utils/decode_irc> is included if you 'use Cobalt::Common'.


=head1 SEE ALSO

Plugin authors should at least read the L<Cobalt::IRC> POD, and 
probably L<Cobalt::Utils> as well.

B<The easiest way to browse documentation is our POD converted to DokuWiki, 
available online:>

L<http://www.cobaltirc.org/docs/wiki/doku.php?id=bots:cobalt:docs:>

FIXME Cobalt-related links

=head2 Relevant CPAN documentation

=over

=item *

L<IRC::Utils>

=item *

L<POE::Component::IRC>

=item *

L<POE::Component::IRC::State>

=item *

L<POE::Component::Syndicator>

=item *

L<Object::Pluggable>

=item *

L<Object::Pluggable::Pipeline>

=item *

L<Object::Pluggable::Constants>

=back


=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

http://www.cobaltirc.org


=cut
