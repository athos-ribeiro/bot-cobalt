=pod

=head1 NAME

Manual::Plugins - Cobalt2 plugin-writing fundamentals guide

=head1 VERSION

Plugins guide revision: 0004

Last updated for cobalt 2.00

=head1 DESCRIPTION

This POD attempts to be a reasonably complete guide to writing useful 
B<Cobalt2> plugins.

Refer to L</SEE ALSO> for other relevant documentation.

B<Plugin authors should at least read the L<Cobalt::IRC> POD!>


=head1 PLUGIN FUNDAMENTALS

=head2 Module paths and configuration

=head3 plugins.conf

Plugins specified in plugins.conf (located in our etc/) will be 
automatically loaded at runtime.

C<plugins.conf> is YAML in the following structure:

  ---
  MyPlugin:
    Module: Cobalt::Plugin::User::MyPlugin
    Config: plugins/mine/myplugin.conf
    ## Optional:
    Opts:
      Level: 2

Configuration files specified in 'Config: ' are expected to be valid 
B<YAML1.0>. You can read all about YAML at L<http://www.yaml.org> -- 
for the most part, YAML is fairly self-explanatory.

They'll be automatically loaded at load-time; the data structure loaded 
will be stored in the core B<cfg> attribute, keyed by the plugin's 
package name.

Simple plugins might only need one or two config options; in this case, 
you can specify a B<Opts:> directive. It should be a hash (or a list, 
in very odd cases).

If an Opts: directive is supplied, it will be loaded into 
'cfg->{plugin_cf}->{$pkg}->{ExtraOpts}'. See below.


=head3 Accessing plugin configuration

Typically, a plugin's configuration is loaded into memory and stored 
in the Core C<cfg> attribute.

The normal way to access a plugin's configuration structure is via the 
core method B<get_plugin_cfg>:

  ## Our __PACKAGE__ must be specified:
  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ );
  unless ($plug_cf) {
    ## No configuration found for our plugin ...
  }

FIXME examples

FIXME discussion about ExtraOpts

FIXME discussion about direct access

See also: L</"Core methods">



=head2 A basic plugin outline

  package Cobalt::Plugin::User::MyPlugin;
  our $VERSION = '0.001';
  use strict;
  use warnings;
  
  ## You need Object::Pluggable::Constants in order to return valid
  ## pipeline control values, else you might break some or all plugins.
  ##
  ## See "Returning proper values" under "Handling events" in this POD.
  ## 
  ## PLUGIN_EAT_NONE is the most common.
  ##
  ## importing :ALL will give you all of them:
  use Object::Pluggable::Constants qw/ :ALL /;
  
  ## Cobalt::Utils provides many useful methods:
  use Cobalt::Utils qw/ :ALL /;
  
  ## minimalist object constructor:
  sub new { bless( {}, shift ) }
  
  ## called when we are loaded:
  sub Cobalt_register {
    ## handlers receive $self and $core as first two args:
    ## $self is "this object"
    ## $core gives us access to core attributes and methods:
    my ($self, $core) = @_;
    
    ## register to only receive public msg events:
    $core->plugin_register( $self, 'SERVER',
      [ 'public_msg' ]
    );
    
    ## log that we're here now:
    $core->log->info("Registered");

    ## we could save $core to $self->{core} to make life easier 
    ## on our internal methods, perhaps:
    $self->{core} = $core;
    
    ## ALWAYS return an Object::Pluggable::Constants value:
    return PLUGIN_EAT_NONE
  }
  
  ## called when we are unloaded:
  sub Cobalt_unregister {
    my ($self, $core) = @_;
    ## . . . do some clean up, perhaps . . .
    $core->log->info("Unregistering; bye!");
    return PLUGIN_EAT_NONE
  }
  
  ## Syndicated events become prefixed with 'Bot_'
  ## (when called send_event, leave the prefix out)
  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = $$_[0];
    my $msghash = $$_[1];
    ...
  }
  
  1;  ## perl modules must end in '1;'
  

Also see the L<Manual::Examples> POD


=head2 Handling events

Plugins are fundamentally event driven.

A plugin will (usually at load-time) register to receive some set of 
events, which are pushed through the pipeline by the Cobalt core (with 
help from L<POE::Component::Syndicator> and L<Object::Pluggable>).

If your plugin needs to have a certain priority in the pipeline, you're 
going to want to spend some quality time reading the L<Object::Pluggable> 
and especially L<Object::Pluggable::Pipeline> documentation. The methods 
described regarding pipeline manipulation are available via C<$core>.

=head3 Registering for events

Registering for events typically happens at plugin load-time; in other 
words, inside C<Cobalt_register>:

  my ($self, $core) = @_;
  
  $core->plugin_register( $self, 'SERVER',
    [ 'chan_sync' ],
    [ 'public_msg' ],
  );
  
  ## or to receive all events:
  $core->plugin_register( $self, 'SERVER',
    [ 'all' ],
  );


=head3 Event handlers

Syndicated events become prefixed with Bot_ when handed off to plugins:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    my $deref_first_arg = ${ $_[0] };
    ...
  }

B<IMPORTANT: the arguments passed to event handlers are ALWAYS references!>

(Sometimes, they're references to references, such as a hashref.
If you don't know what that means, it's time to read L<perlreftut> and 
L<perlref> immediately.)

This means that it's intended behavior to be able to modify the event's 
arguments before it continues through the plugin pipeline.

Be aware of this behavior and code appropriately.

Don't be confused, yet! For the most part, you can just dereference args 
as shown in the example above.


=head3 Returning proper values

The plugin system is a pipeline.

Unless manipulated manually, Cobalt's pipeline starts with the core 
('Main' context) IRC plugin provided by L<Cobalt::IRC>, followed by 
any plugins specified in plugins.conf.

That being the case, events will be handed on down the pipeline, 
B<unless> a handler for a syndicated event returns an incorrect value.

Your Bot_* event handlers should B<always> return an 
L<Object::Pluggable::Constants> value. The two commonly used values are:

=head4 PLUGIN_EAT_NONE

Allow the event to continue to pass through the pipeline.

B<This is the most common return value for event handlers.>

=head4 PLUGIN_EAT_ALL 

Eat the event, removing it from the plugin pipeline.

Typically you might return *_EAT_ALL on self-syndicated events.

For example, a plugin that breaks up a loop into chunks without its 
own POE session might self-syndicate some kind of loop event, eating 
the event when the loop is complete (also see L</"ADVANCED CONCEPTS">).

This can also be useful when there is a good reason to terminate an 
event's lifetime; for example, implementing a plugin that loads itself 
at the front of the pipeline and restricts outgoing events based on 
some criteria.


=head2 Receiving IRC events

=head3 Understanding server context

FIXME

=head3 Messages

FIXME

=head3 Commands

FIXME

=head3 Other events

All of the typical instances of "stuff going on" on IRC are 
reported by the core IRC module in context "Main"

B<
The documentation for all events parsed and re-broadcast from IRC 
is available via the Cobalt::IRC POD
>

See L<Cobalt::IRC>.

=head2 Sending IRC events

L<Cobalt::IRC> receives the following commonly-used events:

=head3 Sending messages

=head4 send_message

FIXME

=head4 send_notice

FIXME

=head3 Channel-related commands

=head4 join

FIXME

=head4 part

FIXME

=head4 kick

FIXME

=head4 mode

FIXME

=head4 topic

FIXME


=head3 Accessing the IRC component directly

The IRC backend for the core distribution is L<POE::Component::IRC>,
more specifically the C<State> subclass.

L<POE::Component::IRC> is a very mature and complete IRC framework.

If your plugin does any kind of IRC-related heavy lifting, you will 
almost certainly want to consult the documentation for 
L<POE::Component::IRC> and L<POE::Component::IRC::State>.


=head4 Obtaining the IRC component

You can retrieve the IRC component object for direct access via the 
core's get_irc_obj method. Expects a server context:

  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = ${$_[0]};
    my $irc = $core->get_irc_obj($context);
  }


=head4 Frequently useful PoCo::IRC commands

FIXME



=head2 Core methods

The Cobalt core provides various useful accessors and methods for plugins.

B<NOTE:> The object reference to the Cobalt core object is referred to here 
as C<$core>. How you keep track of $core is your business; storing it in 
$self is generally fairly convenient:

  ## often in our Cobalt_register method:
  $self->{core} = $core;
  ...
  ## later, in an internal method...
  my $plug_cf = $self->{core}->get_plugin_cfg(__PACKAGE__);


=head3 Accessors

=head4 get_core_cfg

  my $core_cf = $core->get_core_cfg()

Retrieves the 'core' configuration directives from C<cobalt.conf>.

=head4 get_channels_cfg

  my $chan_cf = $core->get_channels_cfg( $context );

Retrieves per-context channel configuration from C<channels.conf>.

The server context must be specified. 'undef' will be returned if it is not.

Returns an empty hash if there is no channel configuration for this 
server context.

=head4 get_plugin_cfg

  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ ) || {};

Retrieves the configuration hash for a specific plugin.

The package name for the plugin must be specified.

Returns a hashref that is a copy of the plugin's config, as found 
in I<$core->cfg->{plugin_cf}->{__PACKAGE__}>

Returns boolean false if there is no plugin configuration stored in 
memory:

  $core->log->warn("Missing config for __PACKAGE__")
    unless $core->get_plugin_cfg( __PACKAGE__ );


=head4 get_irc_casemap

  my $casemapping = $core->get_irc_casemap( $context );

Retrieves the CASEMAPPING rules for the specified server context, 
which should be one of: I<rfc1459>, I<strict-rfc1459>, I<ascii>

The server's casemapping is (should be) declared in ISUPPORT (numeric 005) 
upon connect and can be used to establish whether or not the character sets 
{}|^ are equivalent to []\~ -- see L</"IRC CAVEATS"> below for more 
information.

This can be used to feed the C<lc_irc/uc_irc/eq_irc> functions from 
L<IRC::Utils> and determine issues like nickname equivalency:

  use IRC::Utils qw/lc_irc eq_irc/;
  my $casemapping = $core->get_irc_casemap( $context );
  my $irc_lower = lc_irc($nickname, $


=head4 get_irc_obj

  my $irc = $core->get_irc_obj( $context );

Retrieve the L<POE::Component::IRC> object for a specified context, which 
is likely to actually be a L<POE::Component::IRC::State> instance.

This can be used to query or post events to the IRC component directly.

See the L<POE::Component::IRC> and L<POE::Component::IRC::State> docs for 
more on interacting directly with the IRC component.


=head4 get_irc_server

  my $server_state = $core->get_irc_server( $context );

Retrieves the appropriate hash reference from B<$core->Servers>

A server context must be specified.

The referenced hash has the following keys:

=over

=item *

B<Object>: The POE::Component::IRC object, see L</get_irc_obj>

=item *

B<Connected>: Boolean true/false; flipped on connect/disconnect events

=item *

B<ConnectedAt>: Most recent irc_001 (welcome) event timestamp

=item *

B<Name>: What we think this server is called

=item *

B<CaseMap>: The server's announced CASEMAPPING (or 'rfc1459'); see L</"IRC CAVEATS">

=item *

B<MaxModes>: The server's announced MAXMODES (or 4)

=back


=head4 auth_level

FIXME

=head4 auth_username

FIXME

=head4 auth_flags

FIXME

=head4 auth_pkg

FIXME


=head3 Logging

FIXME


=head3 Timers

Core timers live in $core->TimerPool ; if need be, you can access 
the timer pool directly via $core->TimerPool->{TIMERS}.

Typically most plugins will only need the following functionality:

=head4 timer_set

Set up a new timer for an event or message.

  $core->timer_set( $delay, $ev_hash );
  $core->timer_set( $delay, $ev_hash, $id );

Returns the timer ID on success, boolean false on failure.

Expects at least a delay (in seconds) and a hashref specifying what to 
do when the delay has elapsed.

  ## New 60 second 'msg' timer with a random unique ID:
  ## Send $string to $channel on $context
  ## (A triggered 'msg' timer broadcasts a 'send_message' event)
  my $id = $core->timer_set( 60,
    {
      ## The type of timer; 'msg' or 'event':
      Type => 'msg',

      ## This is a 'msg' timer; we need to know what to send:
      Context => $context,
      Target  => $channel,
      Text    => $string,
    }
  );


If no B<Type> is specified, I<event> is assumed:

  ## Trigger event $event in $secs with (optional) @args:
  my $id = $core->timer_set( $secs,
    {
      Event => $event,
      Args  => [ @args ],
    }
  );


By default, a random timer ID is chosen (and returned).

You can also specify an ID:

  ## Set a timer with specified ID 'MyTimer'
  ## Will overwrite any preexisting timers with the same ID
  $core->timer_set( 
    $secs,
    { Event => $event, Args => [ @args ] },
    'MyTimer'
  );

This can be useful for resetting timers you've already set; grab the ID 
returned by a C<timer_set()> call and reset it to change the event or delay.

You may want C<timestr_to_secs> from L<Cobalt::Utils> for easy 
conversion of human-readable strings into seconds.

If you need better accuracy, you'll need to use your own alarm()/delay() 
calls to L<POE::Kernel>; the timer pool is checked every second or so.


=head4 timer_del

Delete a timer by ID.

  my $deleted = $core->timer_del( $id );

Returns the deleted TimerPool entry, or nothing if there was no such ID.

The returned result (if there is one) can be fed back to L</timer_set> 
if needed:

  ## hang on to this timer for now:
   my $postponed = $core->timer_del( $id ) ;
  ## . . . situation changes . . .
   if ( $core->timer_set( 60, $postponed, $id ) ) {
     ## readding postponed timer successful
   }


=head4 timer_del_pkg

Delete all core timers owned by __PACKAGE__ :

  $core->timer_del_pkg( __PACKAGE__ );

Typically used by plugins that may need to clean up their core timers 
upon unregistering.


=head2 Syndicated core events

FIXME

=head3 Plugin-related

FIXME

=head3 Langset-related

FIXME

=head3 Timer-related

FIXME

=head3 Auth module

FIXME



=head1 PLUGIN DESIGN TIPS

=head2 Useful tools

FIXME

=head3 Cobalt::Utils

FIXME brief primer on useful Cobalt::Utils funcs

=head3 IRC::Utils

FIXME brief primer on IRC::Utils funcs

=head2 Keeping track of $core

FIXME

=head2 Using Moose

FIXME


=head1 ADVANCED CONCEPTS

=head2 Breaking up lengthy loops

FIXME discussion of pushing self-events back to pipeline to loop

=head2 Custom per-plugin language sets

FIXME discussion of using load_langset to create a 'local' RPL hash

=head2 Spawning your own POE::Session

FIXME discussion of plugins that initiate their own sessions

FIXME registering for events from irc...?

=head2 Manipulating plugin pipeline order

FIXME

=head2 Using POE::Component::IRC plugins

FIXME


=head1 IRC CAVEATS

=head2 IRC casemapping rules

Determining whether or not nicknames and channels are equivalent on IRC 
is not as easy as it looks.

Per the RFC (L<http://tools.ietf.org/html/rfc1459#section-2.2>):

  the characters {}| are
  considered to be the lower case equivalents of the characters []\,
  respectively

This set ( {}| == []\ ) is called B<strict-rfc1459> and identified as such in 
a server's I<ISUPPORT CASEMAPPING=> directive.

More often, servers use the set commonly identified as B<rfc1459>:

  ## rfc1459 lower->upper case change: {}|^ == []\~
  $value =~ tr/a-z{}|^/A-Z[]\\~/;

Some servers may use normal ASCII case rules; they will typically announce 
B<ascii> in I<CASEMAPPING=>.

L<Cobalt::IRC> will attempt to determine and save a server's CASEMAPPING value 
at connect time. Some broken server configurations announce junk in 
I<CASEMAPPING> and their actual valid casemapping ruleset in I<CHARSET>; 
L<Cobalt::IRC> will fall back to I<CHARSET> if I<CHARSET> is a valid casemap 
but I<CASEMAPPING> is invalid. If all else fails, B<rfc1459> is used. The 
saved value can be used to feed C<eq_irc> and friends from L<IRC::Utils> and
determine nickname/channel equivalency.

See L</get_irc_casemap> and L<IRC::Utils>



=head2 Character encodings

FIXME


=head1 SEE ALSO

Plugin authors should at least read the L<Cobalt::IRC> POD, and 
probably L<Cobalt::Utils> as well.

B<The easiest way to browse documentation is our POD converted to DokuWiki, 
available online:>

L<http://www.cobaltirc.org/docs/wiki/doku.php?id=bots:cobalt:docs:>


=head2 Relevant CPAN documentation

=over

=item *

L<IRC::Utils>

=item *

L<POE::Component::IRC>

=item *

L<POE::Component::IRC::State>

=item *

L<POE::Component::Syndicator>

=item *

L<Object::Pluggable>

=item *

L<Object::Pluggable::Pipeline>

=item *

L<Object::Pluggable::Constants>

=back


=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

http://www.cobaltirc.org


=cut
