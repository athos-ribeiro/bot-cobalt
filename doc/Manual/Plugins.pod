=pod

=head1 NAME

Manual::Plugins - Cobalt2 plugin-writing fundamentals guide

=head1 VERSION

Plugins guide revision: 0003

Last updated for cobalt 2.00

=head1 DESCRIPTION

This POD attempts to be a reasonably complete guide to writing useful 
B<Cobalt2> plugins.

Refer to L</SEE ALSO> for other relevant documentation.

B<Plugin authors should at least read the Plugins::IRC POD!>

  $ cd doc/
  $ perldoc Plugins::IRC


=head1 PLUGIN FUNDAMENTALS

=head2 Module paths and configuration

=head3 plugins.conf

Plugins specified in plugins.conf (located in our etc/) will be 
automatically loaded at runtime.

C<plugins.conf> is YAML in the following structure:

  ---
  MyPlugin:
    Module: Cobalt::Plugin::User::MyPlugin
    Config: plugins/mine/myplugin.conf
    ## Optional:
    Opts:
      Level: 2

Configuration files specified in 'Config: ' are expected to be valid YAML1.0.

For a quick primer, see C<perldoc Manual::PluginConf>. More extensive YAML 
documentation is widely available online.

They'll be automatically loaded at load-time; the data structure loaded 
will be stored in the core 'cfg' attribute. See below.

Simple plugins might only need one or two config options; in this case, 
you can specify a B<Opts:> directive. It should be a hash (or a list, 
in very odd cases).

If an Opts: directive is supplied, it will be loaded into 
'cfg->{plugin_cf}->{$pkg}->{ExtraOpts}'. See below.

=head3 Accessing plugin configuration

Typically, a plugin's configuration is loaded into memory and stored 
in the Core C<cfg> attribute.

The normal way to access a plugin's configuration structure is via the 
core method B<get_plugin_cfg>:

  ## Our __PACKAGE__ must be specified:
  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ );
  unless ($plug_cf) {
    ## No configuration found for our plugin ...
  }

FIXME examples

FIXME discussion about ExtraOpts

FIXME discussion about direct access

See also: L</"Core methods">



=head2 A basic plugin outline

  package Cobalt::Plugin::User::MyPlugin;
  our $VERSION = '0.001';
  use strict;
  use warnings;
  
  ## You need Object::Pluggable::Constants in order to return valid
  ## pipeline control values, else you might break some or all plugins.
  ##
  ## See "Returning proper values" under "Handling events" in this POD.
  ## 
  ## PLUGIN_EAT_NONE is the most common.
  ##
  ## importing :ALL will give you all of them:
  use Object::Pluggable::Constants qw/ :ALL /;
  
  ## Cobalt::Utils provides many useful methods:
  use Cobalt::Utils qw/ :ALL /;
  
  ## minimalist object constructor:
  sub new { bless( {}, shift ) }
  
  ## called when we are loaded:
  sub Cobalt_register {
    ## handlers receive $self and $core as first two args:
    ## $self is "this object"
    ## $core gives us access to core attributes and methods:
    my ($self, $core) = @_;
    
    ## register to only receive public msg events:
    $core->plugin_register( $self, 'SERVER',
      [ 'public_msg' ]
    );
    
    ## log that we're here now:
    $core->log->info("Registered");

    ## we could save $core to $self->{core} to make life easier 
    ## on our internal methods, perhaps:
    $self->{core} = $core;
    
    ## ALWAYS return an Object::Pluggable::Constants value:
    return PLUGIN_EAT_NONE
  }
  
  ## called when we are unloaded:
  sub Cobalt_unregister {
    my ($self, $core) = @_;
    ## . . . do some clean up, perhaps . . .
    $core->log->info("Unregistering; bye!");
    return PLUGIN_EAT_NONE
  }
  
  ## Syndicated events become prefixed with 'Bot_'
  ## (when called send_event, leave the prefix out)
  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = $$_[0];
    my $msghash = $$_[1];
    ...
  }
  
  1;  ## perl modules must end in '1;'
  

Also see the L<Manual::Examples> POD


=head2 Handling events

Plugins are fundamentally event driven.

A plugin will (usually at load-time) register to receive some set of 
events, which are pushed through the pipeline by the Cobalt core (with 
help from L<POE::Component::Syndicator> and L<Object::Pluggable>).

=head3 Registering for events

Registering for events typically happens at plugin load-time; in other 
words, inside C<Cobalt_register>:

  my ($self, $core) = @_;
  
  $core->plugin_register( $self, 'SERVER',
    [ 'chan_sync' ],
    [ 'public_msg' ],
  );
  
  ## or to receive all events:
  $core->plugin_register( $self, 'SERVER',
    [ 'all' ],
  );


=head3 Event handlers

Syndicated events become prefixed with Bot_ when handed off to plugins:

  sub Bot_some_event {
    my ($self, $core) = splice @_, 0, 2;
    my $deref_first_arg = ${ $_[0] };
    ...
  }

B<IMPORTANT: the arguments passed to event handlers are ALWAYS references!>

(Sometimes, they're references to references, such as a hashref.)

(If you don't know what that means, it's time to read L<perlreftut> and 
L<perlref> immediately.)

This means that it's intended behavior to be able to modify the event's 
arguments before it continues through the plugin pipeline.

Be aware of this behavior and code appropriately.

Don't be confused, yet! For the most part, you can just dereference args 
as shown in the example above.


=head3 Returning proper values

The plugin system is a pipeline.

Unless manipulated manually, Cobalt's pipeline starts with the core 
('Main' context) IRC plugin provided by L<Cobalt::IRC>, followed by 
any plugins specified in plugins.conf.

That being the case, events will be handed on down the pipeline, 
B<unless> a handler for a syndicated event returns an incorrect value.

Your Bot_* event handlers should B<always> return an 
L<Object::Pluggable::Constants> value. The two commonly used values are:

=head4 PLUGIN_EAT_NONE

Allow the event to continue to pass through the pipeline.

B<This is the most common return value for event handlers.>

=head4 PLUGIN_EAT_ALL 

Eat the event, removing it from the plugin pipeline.

Typically you might return *_EAT_ALL on self-syndicated events.

For example, a plugin that breaks up a loop into chunks without its 
own POE session might self-syndicate some kind of loop event, eating 
the event when the loop is complete (also see L</"ADVANCED CONCEPTS">).

This can also be useful when there is a good reason to terminate an 
event's lifetime; for example, implementing a plugin that loads itself 
at the front of the pipeline and restricts outgoing events based on 
some criteria.


=head2 Receiving IRC events

=head3 Understanding server context

=head3 Messages

=head3 Commands

=head3 Other events

All of the typical instances of "stuff going on" on IRC are 
reported by the core IRC module in context "Main"

B<
The documentation for all events parsed and re-broadcast from IRC 
is available via the Cobalt::IRC POD
>

See L<Cobalt::IRC>.

=head2 Sending IRC events

L<Cobalt::IRC> receives the following commonly-used events:

=head3 Sending messages

=head4 send_message

=head4 send_notice


=head3 Channel-related commands

=head4 join

=head4 part

=head4 kick

=head4 mode

=head4 topic


=head3 Accessing the IRC component directly

The IRC backend for the core distribution is L<POE::Component::IRC>,
more specifically the C<State> subclass.

L<POE::Component::IRC> is a very mature and complete IRC framework.

If your plugin does any kind of IRC-related heavy lifting, you will 
almost certainly want to consult the documentation for 
L<POE::Component::IRC> and L<POE::Component::IRC::State>.


=head4 Obtaining the IRC component

You can retrieve the IRC component object for direct access via the 
core's get_irc_obj method. Expects a server context:

  sub Bot_public_msg {
    my ($self, $core) = @_;
    my $context = ${$_[0]};
    my $irc = $core->get_irc_obj($context);
  }


=head4 Frequently useful PoCo::IRC commands


=head2 Core methods

The Cobalt core provides various useful accessors and methods for plugins.

B<NOTE:> The object reference to the Cobalt core object is referred to here 
as C<$core>. How you keep track of $core is your business; storing it in 
$self is generally fairly convenient:

  ## often in our Cobalt_register method:
  $self->{core} = $core;
  ...
  ## later, in an internal method...
  my $plug_cf = $self->{core}->get_plugin_cfg(__PACKAGE__);


=head3 Accessors

=head4 get_core_cfg

  my $core_cf = $core->get_core_cfg()

Retrieves the 'core' configuration directives from C<cobalt.conf>.

=head4 get_channels_cfg

  my $chan_cf = $core->get_channels_cfg( $context );

Retrieves per-context channel configuration from C<channels.conf>.

The server context must be specified. 'undef' will be returned if it is not.

Returns an empty hash if there is no channel configuration for this 
server context.

=head4 get_plugin_cfg

  my $plug_cf = $core->get_plugin_cfg( __PACKAGE__ ) || {};

Retrieves the configuration hash for a specific plugin.

The package name for the plugin must be specified.

Returns a hashref that is a copy of the plugin's config, as found 
in I<$core->cfg->{plugin_cf}->{__PACKAGE__}>

Returns boolean false if there is no plugin configuration stored in 
memory:

  $core->log->warn("Missing config for __PACKAGE__")
    unless $core->get_plugin_cfg( __PACKAGE__ );


=head4 get_irc_casemap

  my $casemapping = $core->get_irc_casemap( $context );

Retrieves the CASEMAPPING rules for the specified server context, 
which should be one of: I<rfc1459>, I<strict-rfc1459>, I<ascii>

The server's casemapping is (should be) declared in ISUPPORT (numeric 005) 
upon connect and can be used to establish whether or not the character sets 
{}|^ are equivalent to []\~ -- see L</"IRC CAVEATS"> below for more 
information.

This can be used to feed the C<lc_irc/uc_irc/eq_irc> functions from 
L<IRC::Utils> and determine issues like nickname equivalency:

  use IRC::Utils qw/lc_irc eq_irc/;
  my $casemapping = $core->get_irc_casemap( $context );
  my $irc_lower = lc_irc($nickname, $


=head4 get_irc_obj

  my $irc = $core->get_irc_obj( $context );

Retrieve the L<POE::Component::IRC> object for a specified context, which 
is likely to actually be a L<POE::Component::IRC::State> instance.

This can be used to query or post events to the IRC component directly.

See the L<POE::Component::IRC> and L<POE::Component::IRC::State> docs for 
more on interacting directly with the IRC component.


=head4 get_irc_server

  my $server_state = $core->get_irc_server( $context );

Retrieves the appropriate hash reference from B<$core->Servers>

A server context must be specified.

The referenced hash has the following keys:

=over

=item *

B<Object>: The POE::Component::IRC object, see L</get_irc_obj>

=item *

B<Connected>: Boolean true/false; flipped on connect/disconnect events

=item *

B<ConnectedAt>: Most recent irc_001 (welcome) event timestamp

=item *

B<Name>: What we think this server is called

=item *

B<CaseMap>: The server's announced CASEMAPPING (or 'rfc1459'); see L</"IRC CAVEATS">

=item *

B<MaxModes>: The server's announced MAXMODES (or 4)



=back


=head4 auth_level

=head4 auth_username

=head4 auth_flags

=head4 auth_pkg


=head3 Logging

=head3 Timer management

=head4 timer_set

=head4 timer_del

=head4 timer_del_pkg


=head2 Syndicated core events

=head3 Plugin-related

=head3 Langset-related

=head3 Timer-related

=head3 Auth module


=head1 PLUGIN DESIGN TIPS

=head2 Keeping track of $core


=head2 Using Moose



=head1 ADVANCED CONCEPTS

=head2 Breaking up lengthy loops

FIXME discussion of pushing self-events back to pipeline to loop

=head2 Custom per-plugin language sets

FIXME discussion of using load_langset to create a 'local' RPL hash

=head2 Spawning your own POE::Session

FIXME discussion of plugins that initiate their own sessions

FIXME registering for events from irc...?

=head2 Manipulating plugin pipeline order



=head1 IRC CAVEATS

=head2 IRC casemapping rules



=head2 Character encodings



=head1 SEE ALSO

Plugin authors should at least read the L<Cobalt::IRC> POD, and 
probably L<Cobalt::Utils> as well.

The easiest way to browse documentation is our POD converted to DokuWiki, 
available online:

L<http://www.cobaltirc.org/docs/wiki/doku.php?id=bots:cobalt:docs:>

FIXME


=head2 Relevant modules

=over

=item *

L<POE::Component::Syndicator>

=item *

L<POE::Component::IRC>

=item *

L<POE::Component::IRC::State>

=back


=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

http://www.cobaltirc.org


=cut
